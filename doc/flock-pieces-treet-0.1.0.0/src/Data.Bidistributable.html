<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE BangPatterns #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE DataKinds #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE DeriveGeneric #-}</span><span>
</span><a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE DuplicateRecordFields #-}</span><span>
</span><a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE FlexibleContexts #-}</span><span>
</span><a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE FunctionalDependencies #-}</span><span>
</span><a name="line-8"></a><span class="hs-pragma">{-# LANGUAGE InstanceSigs #-}</span><span>
</span><a name="line-9"></a><span class="hs-pragma">{-# LANGUAGE KindSignatures #-}</span><span>
</span><a name="line-10"></a><span class="hs-pragma">{-# LANGUAGE MultiParamTypeClasses #-}</span><span>
</span><a name="line-11"></a><span class="hs-pragma">{-# LANGUAGE OverloadedStrings #-}</span><span>
</span><a name="line-12"></a><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><a name="line-13"></a><span class="hs-pragma">{-# LANGUAGE TupleSections #-}</span><span>
</span><a name="line-14"></a><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span>
</span><a name="line-15"></a><span>
</span><a name="line-16"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Bidistributable</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-17"></a><span>
</span><a name="line-18"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Applicative</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">liftA2</span><span class="hs-special">)</span><span>
</span><a name="line-19"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Category</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Category</span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-20"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Biapplicative</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Biapplicative</span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">biliftA2</span><span class="hs-special">)</span><span>
</span><a name="line-21"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Bifunctor</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Bifunctor</span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-22"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Either</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">isLeft</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">isRight</span><span class="hs-special">)</span><span>
</span><a name="line-23"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Monoid</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-operator hs-var">&lt;&gt;</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-24"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Prelude</span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">unlines</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">lines</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">id</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">.</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-25"></a><span>
</span><a name="line-26"></a><span>
</span><a name="line-27"></a><span class="hs-comment">-- | Distribute over a `Bifunctor`</span><span>
</span><a name="line-28"></a><span class="hs-keyword">class</span><span> </span><span class="hs-identifier hs-type">Bifunctor</span><span> </span><a href="#local-6989586621679071840"><span class="hs-identifier hs-type">p</span></a><span> </span><span class="hs-glyph">=&gt;</span><span> </span><a name="Bidistributable"><a href="Data.Bidistributable.html#Bidistributable"><span class="hs-identifier">Bidistributable</span></a></a><span> </span><a name="local-6989586621679071840"><a href="#local-6989586621679071840"><span class="hs-identifier">p</span></a></a><span> </span><a name="local-6989586621679071841"><a href="#local-6989586621679071841"><span class="hs-identifier">f</span></a></a><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-29"></a><span>  </span><span class="hs-comment">-- | Later called &quot;push&quot; and or &quot;push2&quot;</span><span>
</span><a name="line-30"></a><span>  </span><span class="hs-identifier">bidistribute</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="#local-6989586621679071841"><span class="hs-identifier hs-type">f</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679071840"><span class="hs-identifier hs-type">p</span></a><span> </span><a href="#local-6989586621679071842"><span class="hs-identifier hs-type">a</span></a><span> </span><a href="#local-6989586621679071843"><span class="hs-identifier hs-type">b</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679071841"><span class="hs-identifier hs-type">f</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679071840"><span class="hs-identifier hs-type">p</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679071841"><span class="hs-identifier hs-type">f</span></a><span> </span><a href="#local-6989586621679071842"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679071841"><span class="hs-identifier hs-type">f</span></a><span> </span><a href="#local-6989586621679071843"><span class="hs-identifier hs-type">b</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-31"></a><span>
</span><a name="line-32"></a><span class="hs-comment">-- | Equivalent to grouping the `Left` and `Right` values together, then sequencing:</span><span>
</span><a name="line-33"></a><span class="hs-comment">--</span><span>
</span><a name="line-34"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-35"></a><span class="hs-comment">--  Right . fmap (fromRight undefined) :: Functor f =&gt; f (Either a b) -&gt; Either a (f b)</span><span>
</span><a name="line-36"></a><span class="hs-comment">--  Left  . fmap (fromLeft  undefined) :: Functor f =&gt; f (Either a b) -&gt; Either (f a) b</span><span>
</span><a name="line-37"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-38"></a><span class="hs-comment">--</span><span>
</span><a name="line-39"></a><span class="hs-keyword">instance</span><span> </span><a href="Data.Bidistributable.html#Bidistributable"><span class="hs-identifier hs-type">Bidistributable</span></a><span> </span><span class="hs-identifier hs-type">Either</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-40"></a><span>  </span><span class="hs-identifier">bidistribute</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Either</span><span> </span><a href="#local-6989586621679071872"><span class="hs-identifier hs-type">a</span></a><span> </span><a href="#local-6989586621679071873"><span class="hs-identifier hs-type">b</span></a><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Either</span><span> </span><span class="hs-special">[</span><a href="#local-6989586621679071872"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><a href="#local-6989586621679071873"><span class="hs-identifier hs-type">b</span></a><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><a name="line-41"></a><span>  </span><a name="local-8214565720323846727"><a href="Data.Bidistributable.html#bidistribute"><span class="hs-identifier">bidistribute</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Left</span><span>  </span><a name="local-6989586621679071874"><a href="#local-6989586621679071874"><span class="hs-identifier">x</span></a></a><span> </span><span class="hs-glyph">:</span><span> </span><a name="local-6989586621679071875"><a href="#local-6989586621679071875"><span class="hs-identifier">xs</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">uncurry</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">)</span><span>        </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">bimap</span><span>              </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Left</span><span>  </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679071874"><span class="hs-identifier hs-var">x</span></a><span> </span><span class="hs-glyph">:</span><span class="hs-special">)</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">fmap</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="hs-glyph">~</span><span class="hs-special">(</span><span class="hs-identifier hs-var">Left</span><span>  </span><a name="local-6989586621679071876"><a href="#local-6989586621679071876"><span class="hs-identifier">y</span></a></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679071876"><span class="hs-identifier hs-var">y</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><a href="Data.Bidistributable.html#bidistribute"><span class="hs-identifier hs-var">bidistribute</span></a><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">Prelude</span><span class="hs-operator hs-var">.</span><span class="hs-identifier hs-var">span</span><span> </span><span class="hs-identifier hs-var">isLeft</span><span>  </span><span class="hs-operator hs-var">$</span><span> </span><a href="#local-6989586621679071875"><span class="hs-identifier hs-var">xs</span></a><span>
</span><a name="line-42"></a><span>  </span><span class="hs-identifier">bidistribute</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Right</span><span> </span><a name="local-6989586621679072036"><a href="#local-6989586621679072036"><span class="hs-identifier">x</span></a></a><span> </span><span class="hs-glyph">:</span><span> </span><a name="local-6989586621679072037"><a href="#local-6989586621679072037"><span class="hs-identifier">xs</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">uncurry</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">flip</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">bimap</span><span> </span><a href="Data.Bidistributable.html#bidistribute"><span class="hs-identifier hs-var">bidistribute</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Right</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679072036"><span class="hs-identifier hs-var">x</span></a><span> </span><span class="hs-glyph">:</span><span class="hs-special">)</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">fmap</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="hs-glyph">~</span><span class="hs-special">(</span><span class="hs-identifier hs-var">Right</span><span> </span><a name="local-6989586621679072038"><a href="#local-6989586621679072038"><span class="hs-identifier">y</span></a></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679072038"><span class="hs-identifier hs-var">y</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-operator hs-var">.</span><span>              </span><span class="hs-identifier hs-var">Prelude</span><span class="hs-operator hs-var">.</span><span class="hs-identifier hs-var">span</span><span> </span><span class="hs-identifier hs-var">isRight</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><a href="#local-6989586621679072037"><span class="hs-identifier hs-var">xs</span></a><span>
</span><a name="line-43"></a><span>  </span><span class="hs-identifier">bidistribute</span><span>  </span><span class="hs-identifier">_</span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><a name="line-44"></a><span>
</span><a name="line-45"></a><span>
</span><a name="line-46"></a><span>
</span><a name="line-47"></a><span class="hs-keyword">class</span><span> </span><a name="Swap"><a href="Data.Bidistributable.html#Swap"><span class="hs-identifier">Swap</span></a></a><span> </span><a name="local-6989586621679071837"><a href="#local-6989586621679071837"><span class="hs-identifier">p</span></a></a><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-48"></a><span>  </span><span class="hs-identifier">swap</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="#local-6989586621679071837"><span class="hs-identifier hs-type">p</span></a><span> </span><a href="#local-6989586621679071838"><span class="hs-identifier hs-type">a</span></a><span> </span><a href="#local-6989586621679071839"><span class="hs-identifier hs-type">b</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679071837"><span class="hs-identifier hs-type">p</span></a><span> </span><a href="#local-6989586621679071839"><span class="hs-identifier hs-type">b</span></a><span> </span><a href="#local-6989586621679071838"><span class="hs-identifier hs-type">a</span></a><span>
</span><a name="line-49"></a><span>
</span><a name="line-50"></a><span class="hs-keyword">instance</span><span> </span><a href="Data.Bidistributable.html#Swap"><span class="hs-identifier hs-type">Swap</span></a><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-51"></a><span>  </span><a name="local-8214565720323846725"><a href="Data.Bidistributable.html#swap"><span class="hs-identifier">swap</span></a></a><span> </span><span class="hs-glyph">~</span><span class="hs-special">(</span><a name="local-6989586621679071870"><a href="#local-6989586621679071870"><span class="hs-identifier">x</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679071871"><a href="#local-6989586621679071871"><span class="hs-identifier">y</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679071871"><span class="hs-identifier hs-var">y</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679071870"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">)</span><span>
</span><a name="line-52"></a><span>
</span><a name="line-53"></a><span class="hs-keyword">instance</span><span> </span><a href="Data.Bidistributable.html#Swap"><span class="hs-identifier hs-type">Swap</span></a><span> </span><span class="hs-identifier hs-type">Either</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-54"></a><span>  </span><a name="local-8214565720323846725"><a href="Data.Bidistributable.html#swap"><span class="hs-identifier">swap</span></a></a><span>  </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Left</span><span>  </span><a name="local-6989586621679071868"><a href="#local-6989586621679071868"><span class="hs-identifier">x</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Right</span><span> </span><a href="#local-6989586621679071868"><span class="hs-identifier hs-var">x</span></a><span>
</span><a name="line-55"></a><span>  </span><span class="hs-identifier">swap</span><span> </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span class="hs-identifier hs-var">Right</span><span> </span><a name="local-6989586621679071869"><a href="#local-6989586621679071869"><span class="hs-identifier">x</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Left</span><span>  </span><a href="#local-6989586621679071869"><span class="hs-identifier hs-var">x</span></a><span>
</span><a name="line-56"></a><span>
</span><a name="line-57"></a><span>
</span><a name="line-58"></a><span>
</span><a name="line-59"></a><span class="hs-comment">-- | `Rope` transformer type</span><span>
</span><a name="line-60"></a><span class="hs-keyword">newtype</span><span> </span><a name="RopeT"><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier">RopeT</span></a></a><span> </span><a name="local-6989586621679071833"><a href="#local-6989586621679071833"><span class="hs-identifier">p</span></a></a><span> </span><a name="local-6989586621679071834"><a href="#local-6989586621679071834"><span class="hs-identifier">m</span></a></a><span> </span><a name="local-6989586621679071835"><a href="#local-6989586621679071835"><span class="hs-identifier">a</span></a></a><span> </span><a name="local-6989586621679071836"><a href="#local-6989586621679071836"><span class="hs-identifier">b</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a name="RopeT"><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier">RopeT</span></a></a><span> </span><span class="hs-special">{</span><span> </span><a name="%24sel%3ApullRopeT%3ARopeT"><a href="Data.Bidistributable.html#%24sel%3ApullRopeT%3ARopeT"><span class="hs-identifier">pullRopeT</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><a href="#local-6989586621679071833"><span class="hs-identifier hs-type">p</span></a><span> </span><a href="#local-6989586621679071835"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679071834"><span class="hs-identifier hs-type">m</span></a><span> </span><span class="hs-special">(</span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-type">RopeT</span></a><span> </span><a href="#local-6989586621679071833"><span class="hs-identifier hs-type">p</span></a><span> </span><a href="#local-6989586621679071834"><span class="hs-identifier hs-type">m</span></a><span> </span><a href="#local-6989586621679071836"><span class="hs-identifier hs-type">b</span></a><span> </span><a href="#local-6989586621679071835"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><a name="line-61"></a><span>
</span><a name="line-62"></a><span class="hs-keyword">instance</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Bifunctor</span><span> </span><a href="#local-6989586621679071864"><span class="hs-identifier hs-type">p</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Functor</span><span> </span><a href="#local-6989586621679071865"><span class="hs-identifier hs-type">m</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-identifier hs-type">Bifunctor</span><span> </span><span class="hs-special">(</span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-type">RopeT</span></a><span> </span><a href="#local-6989586621679071864"><span class="hs-identifier hs-type">p</span></a><span> </span><a href="#local-6989586621679071865"><span class="hs-identifier hs-type">m</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-63"></a><span>  </span><a name="local-8214565720323787714"><span class="hs-identifier">bimap</span></a><span> </span><a name="local-6989586621679071866"><a href="#local-6989586621679071866"><span class="hs-identifier">f</span></a></a><span> </span><a name="local-6989586621679071867"><a href="#local-6989586621679071867"><span class="hs-identifier">g</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-var">RopeT</span></a><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">bimap</span><span> </span><a href="#local-6989586621679071866"><span class="hs-identifier hs-var">f</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">fmap</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">bimap</span><span> </span><a href="#local-6989586621679071867"><span class="hs-identifier hs-var">g</span></a><span> </span><a href="#local-6989586621679071866"><span class="hs-identifier hs-var">f</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier">pullRopeT</span><span>
</span><a name="line-64"></a><span>
</span><a name="line-65"></a><span class="hs-keyword">instance</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Bifunctor</span><span> </span><a href="#local-6989586621679071861"><span class="hs-identifier hs-type">p</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Functor</span><span> </span><a href="#local-6989586621679071862"><span class="hs-identifier hs-type">m</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-identifier hs-type">Functor</span><span> </span><span class="hs-special">(</span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-type">RopeT</span></a><span> </span><a href="#local-6989586621679071861"><span class="hs-identifier hs-type">p</span></a><span> </span><a href="#local-6989586621679071862"><span class="hs-identifier hs-type">m</span></a><span> </span><a href="#local-6989586621679071863"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-66"></a><span>  </span><a name="local-3458764513820541101"><span class="hs-identifier">fmap</span></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">second</span><span>
</span><a name="line-67"></a><span>
</span><a name="line-68"></a><span>
</span><a name="line-69"></a><span class="hs-keyword">instance</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Biapplicative</span><span> </span><a href="#local-6989586621679071851"><span class="hs-identifier hs-type">p</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Applicative</span><span> </span><a href="#local-6989586621679071852"><span class="hs-identifier hs-type">m</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-identifier hs-type">Biapplicative</span><span> </span><span class="hs-special">(</span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-type">RopeT</span></a><span> </span><a href="#local-6989586621679071851"><span class="hs-identifier hs-type">p</span></a><span> </span><a href="#local-6989586621679071852"><span class="hs-identifier hs-type">m</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-70"></a><span>  </span><a name="local-8214565720323791533"><span class="hs-identifier">bipure</span></a><span> </span><a name="local-6989586621679071857"><a href="#local-6989586621679071857"><span class="hs-identifier">x</span></a></a><span> </span><a name="local-6989586621679071858"><a href="#local-6989586621679071858"><span class="hs-identifier">y</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-var">RopeT</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">bipure</span><span> </span><a href="#local-6989586621679071857"><span class="hs-identifier hs-var">x</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">pure</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">bipure</span><span> </span><a href="#local-6989586621679071858"><span class="hs-identifier hs-var">y</span></a><span> </span><a href="#local-6989586621679071857"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-71"></a><span>
</span><a name="line-72"></a><span>  </span><span class="hs-special">(</span><span class="hs-operator">&lt;&lt;*&gt;&gt;</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-type">RopeT</span></a><span> </span><a href="#local-6989586621679071851"><span class="hs-identifier hs-type">p</span></a><span> </span><a href="#local-6989586621679071852"><span class="hs-identifier hs-type">m</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679071853"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679071854"><span class="hs-identifier hs-type">b</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679071855"><span class="hs-identifier hs-type">c</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679071856"><span class="hs-identifier hs-type">d</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-type">RopeT</span></a><span> </span><a href="#local-6989586621679071851"><span class="hs-identifier hs-type">p</span></a><span> </span><a href="#local-6989586621679071852"><span class="hs-identifier hs-type">m</span></a><span> </span><a href="#local-6989586621679071853"><span class="hs-identifier hs-type">a</span></a><span> </span><a href="#local-6989586621679071855"><span class="hs-identifier hs-type">c</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-type">RopeT</span></a><span> </span><a href="#local-6989586621679071851"><span class="hs-identifier hs-type">p</span></a><span> </span><a href="#local-6989586621679071852"><span class="hs-identifier hs-type">m</span></a><span> </span><a href="#local-6989586621679071854"><span class="hs-identifier hs-type">b</span></a><span> </span><a href="#local-6989586621679071856"><span class="hs-identifier hs-type">d</span></a><span>
</span><a name="line-73"></a><span>  </span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-var">RopeT</span></a><span> </span><a name="local-6989586621679071859"><a href="#local-6989586621679071859"><span class="hs-identifier">f</span></a></a><span> </span><a name="local-8214565720323791532"><span class="hs-operator">&lt;&lt;*&gt;&gt;</span></a><span> </span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-var">RopeT</span></a><span> </span><a name="local-6989586621679071860"><a href="#local-6989586621679071860"><span class="hs-identifier">x</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-var">RopeT</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">biliftA2</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">$</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">liftA2</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">&lt;&lt;*&gt;&gt;</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><a href="#local-6989586621679071859"><span class="hs-identifier hs-var">f</span></a><span> </span><a href="#local-6989586621679071860"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">)</span><span>
</span><a name="line-74"></a><span>
</span><a name="line-75"></a><span>
</span><a name="line-76"></a><span class="hs-keyword">instance</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Biapplicative</span><span> </span><a href="#local-6989586621679071844"><span class="hs-identifier hs-type">p</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Applicative</span><span> </span><a href="#local-6989586621679071845"><span class="hs-identifier hs-type">m</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Monoid</span><span> </span><a href="#local-6989586621679071846"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-identifier hs-type">Applicative</span><span> </span><span class="hs-special">(</span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-type">RopeT</span></a><span> </span><a href="#local-6989586621679071844"><span class="hs-identifier hs-type">p</span></a><span> </span><a href="#local-6989586621679071845"><span class="hs-identifier hs-type">m</span></a><span> </span><a href="#local-6989586621679071846"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-77"></a><span>  </span><a name="local-3458764513820541680"><span class="hs-identifier">pure</span></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">bipure</span><span> </span><span class="hs-identifier hs-var">mempty</span><span>
</span><a name="line-78"></a><span>
</span><a name="line-79"></a><span>  </span><span class="hs-special">(</span><span class="hs-operator">&lt;*&gt;</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-type">RopeT</span></a><span> </span><a href="#local-6989586621679071844"><span class="hs-identifier hs-type">p</span></a><span> </span><a href="#local-6989586621679071845"><span class="hs-identifier hs-type">m</span></a><span> </span><a href="#local-6989586621679071846"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679071847"><span class="hs-identifier hs-type">b</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679071848"><span class="hs-identifier hs-type">c</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-type">RopeT</span></a><span> </span><a href="#local-6989586621679071844"><span class="hs-identifier hs-type">p</span></a><span> </span><a href="#local-6989586621679071845"><span class="hs-identifier hs-type">m</span></a><span> </span><a href="#local-6989586621679071846"><span class="hs-identifier hs-type">a</span></a><span> </span><a href="#local-6989586621679071847"><span class="hs-identifier hs-type">b</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-type">RopeT</span></a><span> </span><a href="#local-6989586621679071844"><span class="hs-identifier hs-type">p</span></a><span> </span><a href="#local-6989586621679071845"><span class="hs-identifier hs-type">m</span></a><span> </span><a href="#local-6989586621679071846"><span class="hs-identifier hs-type">a</span></a><span> </span><a href="#local-6989586621679071848"><span class="hs-identifier hs-type">c</span></a><span>
</span><a name="line-80"></a><span>  </span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-var">RopeT</span></a><span> </span><a name="local-6989586621679071849"><a href="#local-6989586621679071849"><span class="hs-identifier">f</span></a></a><span> </span><a name="local-3458764513820541679"><span class="hs-operator">&lt;*&gt;</span></a><span> </span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-var">RopeT</span></a><span> </span><a name="local-6989586621679071850"><a href="#local-6989586621679071850"><span class="hs-identifier">x</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Data.Bidistributable.html#RopeT"><span class="hs-identifier hs-var">RopeT</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">biliftA2</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">&lt;&gt;</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">liftA2</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">biliftA2</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">$</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">&lt;&gt;</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><a href="#local-6989586621679071849"><span class="hs-identifier hs-var">f</span></a><span> </span><a href="#local-6989586621679071850"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">)</span><span>
</span><a name="line-81"></a><span>
</span><a name="line-82"></a><span>
</span><a name="line-83"></a><span>
</span><a name="line-84"></a><span>
</span><a name="line-85"></a><span class="hs-comment">-- | Commonly used variable types:</span><span>
</span><a name="line-86"></a><span class="hs-comment">--</span><span>
</span><a name="line-87"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-88"></a><span class="hs-comment">-- f :: t -&gt; t</span><span>
</span><a name="line-89"></a><span class="hs-comment">-- g :: t -&gt; t</span><span>
</span><a name="line-90"></a><span class="hs-comment">-- a :: t</span><span>
</span><a name="line-91"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-92"></a><span class="hs-comment">--</span><span>
</span><a name="line-93"></a><span class="hs-identifier">commonVariableTypes</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-94"></a><a name="commonVariableTypes"><a href="Data.Bidistributable.html#commonVariableTypes"><span class="hs-identifier">commonVariableTypes</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-95"></a><span>
</span><a name="line-96"></a><span>
</span><a name="line-97"></a><span class="hs-comment">-- | Let @C@ be a category. @F@ associates (@X@ is an object in @C@ and @G(X)@ is as well):</span><span>
</span><a name="line-98"></a><span class="hs-comment">--</span><span>
</span><a name="line-99"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-100"></a><span class="hs-comment">--   a  :: X      =&gt; F(a) :: F(X)</span><span>
</span><a name="line-101"></a><span class="hs-comment">--   f  :: X -&gt; Y =&gt; F(f) :: F(X) -&gt; F(Y)</span><span>
</span><a name="line-102"></a><span class="hs-comment">--   id_X :: X -&gt; X =&gt; F(id_X) = id_F(X) :: F(X) -&gt; F(X)</span><span>
</span><a name="line-103"></a><span class="hs-comment">--   f :: X -&gt; Y, g :: Y -&gt; Z, g . f :: X -&gt; Z =&gt; F (g . f) = F(g) . F(f) :: F(X) -&gt; F(Z)</span><span>
</span><a name="line-104"></a><span class="hs-comment">--</span><span>
</span><a name="line-105"></a><span class="hs-comment">--                      G associates (X is an object in C and G(X) is as well)</span><span>
</span><a name="line-106"></a><span class="hs-comment">--   a  :: X      =&gt; G(a) :: G(X)</span><span>
</span><a name="line-107"></a><span class="hs-comment">--   f  :: X -&gt; Y =&gt; G(f) :: G(X) -&gt; G(Y)</span><span>
</span><a name="line-108"></a><span class="hs-comment">--   id_X :: X -&gt; X =&gt; G(id_X) = id_G(X) :: G(X) -&gt; G(X)</span><span>
</span><a name="line-109"></a><span class="hs-comment">--   f :: X -&gt; Y, g :: Y -&gt; Z, g . f :: X -&gt; Z =&gt; G (g . f) = G(g) . G(f) :: G(X) -&gt; G(Z)</span><span>
</span><a name="line-110"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-111"></a><span class="hs-comment">--</span><span>
</span><a name="line-112"></a><span class="hs-identifier">functorNotes</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-113"></a><a name="functorNotes"><a href="Data.Bidistributable.html#functorNotes"><span class="hs-identifier">functorNotes</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-114"></a><span>
</span><a name="line-115"></a><span>
</span><a name="line-116"></a><span class="hs-comment">-- | We want: functor isomorphisms between these compositions of F and G:</span><span>
</span><a name="line-117"></a><span class="hs-comment">--</span><span>
</span><a name="line-118"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-119"></a><span class="hs-comment">--   F(G(A))    -- we have a composition of functors</span><span>
</span><a name="line-120"></a><span class="hs-comment">--   F(F(G(A))) -- we partition the outer functor into pieces such that `unique partition (xs :: f (g a))` is true for our partition (if it exists, of course, that's where graph coloring comes in)</span><span>
</span><a name="line-121"></a><span class="hs-comment">--   F(G(F(A))) -- we push the partition into the inner functor, resulting in the connected (f (g a)) pieces being joined along their partitions.</span><span>
</span><a name="line-122"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-123"></a><span class="hs-comment">--</span><span>
</span><a name="line-124"></a><span class="hs-comment">-- In other words, it pulls the partition up to F's level while pushing the structure of F down into G. The structure of F is available to G in slices (local by definition of the partition).</span><span>
</span><a name="line-125"></a><span class="hs-comment">--</span><span>
</span><a name="line-126"></a><span class="hs-comment">-- Note: all of these operations are invertible since we have unique partitions.</span><span>
</span><a name="line-127"></a><span class="hs-comment">--</span><span>
</span><a name="line-128"></a><span class="hs-comment">-- Additionally, the functors which this works for are local functors and computers _really_ like computational and data locality. Like they simply adore it.</span><span>
</span><a name="line-129"></a><span class="hs-comment">-- Computational locality makes stream and massively parallel processing a breeze (case in point, the line-by-line parser I just wrote)</span><span>
</span><a name="line-130"></a><span class="hs-comment">--</span><span>
</span><a name="line-131"></a><span class="hs-identifier">functorIsomorphismCompositions</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-132"></a><a name="functorIsomorphismCompositions"><a href="Data.Bidistributable.html#functorIsomorphismCompositions"><span class="hs-identifier">functorIsomorphismCompositions</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-133"></a><span>
</span><a name="line-134"></a><span>
</span><a name="line-135"></a><span class="hs-comment">-- | That is, we want three natural transformations that are also isomorphisms between those compositions.</span><span>
</span><a name="line-136"></a><span class="hs-comment">--</span><span>
</span><a name="line-137"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-138"></a><span class="hs-comment">--   f :: X -&gt; Y =&gt; F(G(f)) :: F(G(X)) -&gt; F(G(Y))</span><span>
</span><a name="line-139"></a><span class="hs-comment">--</span><span>
</span><a name="line-140"></a><span class="hs-comment">--   X :: C =&gt; eta_1(X) :: F(G(X)) -&gt; F(F(G(X))) :: C -&gt; C</span><span>
</span><a name="line-141"></a><span class="hs-comment">--   X :: C =&gt; eta_2(X) :: F(F(G(X))) -&gt; F(G(F(X))) :: C -&gt; C</span><span>
</span><a name="line-142"></a><span class="hs-comment">--   X :: C =&gt; eta_3(X) :: F(G(F(X))) -&gt; F(G(X)) :: C -&gt; C</span><span>
</span><a name="line-143"></a><span class="hs-comment">--</span><span>
</span><a name="line-144"></a><span class="hs-comment">--   f :: X -&gt; Y :: C -&gt; C =&gt; eta_1(Y) . F(G(f)) = F(F(G(f))) . eta_1(X) :: F(G(X)) -&gt; F(F(G(Y))) :: C -&gt; C</span><span>
</span><a name="line-145"></a><span class="hs-comment">--   f :: X -&gt; Y :: C -&gt; C =&gt; eta_2(Y) . F(F(G(f))) = F(G(F(f))) . eta_2(X) :: F(F(G(X))) -&gt; F(G(F(Y))) :: C -&gt; C</span><span>
</span><a name="line-146"></a><span class="hs-comment">--   f :: X -&gt; Y :: C -&gt; C =&gt; eta_3(Y) . F(G(F(f))) = F(G(f)) . eta_3(X) :: F(G(F(X))) -&gt; F(G(Y)) :: C -&gt; C</span><span>
</span><a name="line-147"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-148"></a><span class="hs-comment">--</span><span>
</span><a name="line-149"></a><span class="hs-comment">-- We require these natural transformations to be bijections.</span><span>
</span><a name="line-150"></a><span class="hs-comment">--</span><span>
</span><a name="line-151"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-152"></a><span class="hs-comment">-- The three base words (those functor compositions) are equivalent</span><span>
</span><a name="line-153"></a><span class="hs-comment">-- Functor composition is associative</span><span>
</span><a name="line-154"></a><span class="hs-comment">-- We have a compositional identity, the identity functor</span><span>
</span><a name="line-155"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-156"></a><span class="hs-comment">--</span><span>
</span><a name="line-157"></a><span class="hs-identifier">naturalIsomorphisms</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-158"></a><a name="naturalIsomorphisms"><a href="Data.Bidistributable.html#naturalIsomorphisms"><span class="hs-identifier">naturalIsomorphisms</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-159"></a><span>
</span><a name="line-160"></a><span>
</span><a name="line-161"></a><span class="hs-comment">-- | We thus have a group with the binary operation (.), identity the category identity, every element is invertible because we have isomorphisms between the compositions.</span><span>
</span><a name="line-162"></a><span class="hs-comment">--</span><span>
</span><a name="line-163"></a><span class="hs-comment">-- It has the presentation: @f g = f f g = f g f@.</span><span>
</span><a name="line-164"></a><span class="hs-comment">--</span><span>
</span><a name="line-165"></a><span class="hs-comment">-- Since it is a group, we can form the language of elements equivalent to those three words.</span><span>
</span><a name="line-166"></a><span class="hs-comment">--</span><span>
</span><a name="line-167"></a><span class="hs-comment">-- This diagram makes it clear:</span><span>
</span><a name="line-168"></a><span class="hs-comment">--</span><span>
</span><a name="line-169"></a><span class="hs-comment">-- (the lines are equivalence and the . is composition)</span><span>
</span><a name="line-170"></a><span class="hs-comment">--</span><span>
</span><a name="line-171"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-172"></a><span class="hs-comment">--</span><span>
</span><a name="line-173"></a><span class="hs-comment">--             (f . g)</span><span>
</span><a name="line-174"></a><span class="hs-comment">--               / \
--              /   \
--             /     \
--            /       \
--           /         \
--   f . (f . g) --- (f . g) . f</span><span>
</span><a name="line-180"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-181"></a><span>
</span><a name="line-182"></a><span class="hs-comment">-- | First of all, we have the word &quot;fg&quot;.</span><span>
</span><a name="line-183"></a><span class="hs-comment">--</span><span>
</span><a name="line-184"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-185"></a><span class="hs-comment">--   Next, we have the word formed by performing the substitution &quot;fg -&gt; fgf&quot;, namely &quot;fgf&quot;.</span><span>
</span><a name="line-186"></a><span class="hs-comment">--   Next, we have the word formed by performing the substitution &quot;fg -&gt; ffg&quot;, namely &quot;ffg&quot;.</span><span>
</span><a name="line-187"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-188"></a><span class="hs-comment">--</span><span>
</span><a name="line-189"></a><span class="hs-comment">-- The substitution rules in full are as follows (with the substring &quot;fg&quot; wrapped in parentheses for emphasis alone):</span><span>
</span><a name="line-190"></a><span class="hs-comment">--</span><span>
</span><a name="line-191"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-192"></a><span class="hs-comment">--  &quot;(fg)  -&gt; f(fg)&quot;</span><span>
</span><a name="line-193"></a><span class="hs-comment">--  &quot;f(fg) -&gt; (fg)&quot;</span><span>
</span><a name="line-194"></a><span class="hs-comment">--  &quot;(fg)  -&gt; (fg)f&quot;</span><span>
</span><a name="line-195"></a><span class="hs-comment">--  &quot;(fg)f -&gt; (fg)&quot;</span><span>
</span><a name="line-196"></a><span class="hs-comment">--  &quot;f(fg) -&gt; (fg)f&quot;</span><span>
</span><a name="line-197"></a><span class="hs-comment">--  &quot;(fg)f -&gt; f(fg)&quot;</span><span>
</span><a name="line-198"></a><span class="hs-comment">--  ----------------</span><span>
</span><a name="line-199"></a><span class="hs-comment">--    It's a rote exercise to show that any rule of the form &quot;f?(fg)f? -&gt; f?(fg)f?&quot; can be derived.</span><span>
</span><a name="line-200"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-201"></a><span class="hs-comment">--</span><span>
</span><a name="line-202"></a><span class="hs-comment">-- Since the substring &quot;fg&quot; can never be broken by the available base rules, we simply have the ability to induct on &quot;f?(fg)f? -&gt; f?(fg)f?&quot; to form &quot;f{n}(fg)f{m}&quot; for any n,m.</span><span>
</span><a name="line-203"></a><span class="hs-comment">--</span><span>
</span><a name="line-204"></a><span class="hs-comment">-- We simply compose the base rule with itself (max n m) times. We then resolve the optionals (?'s) to the number of &quot;f&quot;'s desired on either side of the &quot;(fg)&quot; center.</span><span>
</span><a name="line-205"></a><span class="hs-comment">--</span><span>
</span><a name="line-206"></a><span class="hs-comment">-- We thus have that this language is exactly the regular language: @&quot;(f*)(fg)(f*)&quot;@</span><span>
</span><a name="line-207"></a><span class="hs-comment">--</span><span>
</span><a name="line-208"></a><span class="hs-identifier">regularLanguage</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-209"></a><a name="regularLanguage"><a href="Data.Bidistributable.html#regularLanguage"><span class="hs-identifier">regularLanguage</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-210"></a><span>
</span><a name="line-211"></a><span>
</span><a name="line-212"></a><span class="hs-comment">-- | One example application is @[], Maybe@, where pushing @([Maybe a] -&gt; [Maybe [a]])@ partitions by isJust. This is stream-friendly.</span><span>
</span><a name="line-213"></a><span class="hs-comment">--</span><span>
</span><a name="line-214"></a><span class="hs-comment">-- Another example is @ListT IO, Threaded@, where @Threaded@ is a comonad that evaluates its contents on extract,</span><span>
</span><a name="line-215"></a><span class="hs-comment">-- which we can do purely since we're still inside of @ListT IO@ and couldn't do otherwise.</span><span>
</span><a name="line-216"></a><span class="hs-comment">--</span><span>
</span><a name="line-217"></a><span class="hs-comment">-- Pushing in is some parallel execution strategy, in that case.</span><span>
</span><a name="line-218"></a><span class="hs-comment">--</span><span>
</span><a name="line-219"></a><span class="hs-comment">-- In other words, we can use this to treat monads as comonads. We just do: @(Monad m =&gt; Turn (Compose m f) m)@ and the inner @m@ can be treated as a comonad inside the turn.</span><span>
</span><a name="line-220"></a><span class="hs-comment">--</span><span>
</span><a name="line-221"></a><span class="hs-comment">-- I.e. we have: @Monad m =&gt; m (Comonad m =&gt; ())@</span><span>
</span><a name="line-222"></a><span class="hs-comment">--</span><span>
</span><a name="line-223"></a><span class="hs-comment">-- This could be well-typed if GHC supported impredicative polymorphism, but it doesn't.</span><span>
</span><a name="line-224"></a><span class="hs-comment">--</span><span>
</span><a name="line-225"></a><span class="hs-comment">-- How does it work?</span><span>
</span><a name="line-226"></a><span class="hs-comment">--</span><span>
</span><a name="line-227"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-228"></a><span class="hs-comment">--  Well, inside of `m`, we have extract (m (m a) -&gt; m a), which is just join</span><span>
</span><a name="line-229"></a><span class="hs-comment">--  Also, inside of `m`, we still have return so then we get duplicate (m (m a) -&gt; m (m (m a))), which is return = fmap return</span><span>
</span><a name="line-230"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-231"></a><span class="hs-comment">--</span><span>
</span><a name="line-232"></a><span class="hs-comment">-- Inside of a comonad, we get a monad. This is the free comonad (/monad)</span><span>
</span><a name="line-233"></a><span class="hs-comment">--</span><span>
</span><a name="line-234"></a><span class="hs-comment">-- Ahhh, don't forget about orthogonal lists, e.g. a 2d array. this may be able to pass layers in and out</span><span>
</span><a name="line-235"></a><span class="hs-identifier">exampleApplications</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-236"></a><a name="exampleApplications"><a href="Data.Bidistributable.html#exampleApplications"><span class="hs-identifier">exampleApplications</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-237"></a><span>
</span><a name="line-238"></a><span class="hs-comment">-- | Really, we want two applications of push to be equivalent to pure push (we don't gain anything from pushing more)</span><span>
</span><a name="line-239"></a><span class="hs-comment">--   (the benefit is that it's equivalent to the limit of the other pushes OR you can consider it as a guarantee that everything to be pushed is pushed in the first push)</span><span>
</span><a name="line-240"></a><span class="hs-comment">--</span><span>
</span><a name="line-241"></a><span class="hs-comment">-- This is: &quot;pushes are effectively idempotent&quot;</span><span>
</span><a name="line-242"></a><span class="hs-comment">-- (using some &quot;generic&quot; injection into `f` to show that additional pushes do no more than the generic injection)</span><span>
</span><a name="line-243"></a><span class="hs-comment">--</span><span>
</span><a name="line-244"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-245"></a><span class="hs-comment">--   push  :: forall (a :: c). f (g a) -&gt; f (g (f a))</span><span>
</span><a name="line-246"></a><span class="hs-comment">--   puref :: forall (a :: c). a -&gt; f a</span><span>
</span><a name="line-247"></a><span class="hs-comment">--</span><span>
</span><a name="line-248"></a><span class="hs-comment">--   push      . push :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))</span><span>
</span><a name="line-249"></a><span class="hs-comment">--   fmap (fmap puref) . push :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))</span><span>
</span><a name="line-250"></a><span class="hs-comment">--   push . push == fmap (fmap puref) . push</span><span>
</span><a name="line-251"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-252"></a><span class="hs-comment">--</span><span>
</span><a name="line-253"></a><span class="hs-comment">-- This is: &quot;pushes are effectively idempotent&quot;</span><span>
</span><a name="line-254"></a><span class="hs-comment">-- (using some &quot;generic&quot; extraction from `f` (which arguably, we can guarantee in some way when we want all of the strcuture of f that can be pushed to be))</span><span>
</span><a name="line-255"></a><span class="hs-comment">--</span><span>
</span><a name="line-256"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-257"></a><span class="hs-comment">--   push     :: forall (a :: c). f (g a) -&gt; f (g (f a))</span><span>
</span><a name="line-258"></a><span class="hs-comment">--   extractf :: forall (a :: c). f a -&gt; a</span><span>
</span><a name="line-259"></a><span class="hs-comment">--</span><span>
</span><a name="line-260"></a><span class="hs-comment">--   push . push                :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))</span><span>
</span><a name="line-261"></a><span class="hs-comment">--   fmap (fmap extractf) . push . push :: f (g a) -&gt; f (g (f a))</span><span>
</span><a name="line-262"></a><span class="hs-comment">--</span><span>
</span><a name="line-263"></a><span class="hs-comment">--   fmap (fmap extractf) . push . push == push</span><span>
</span><a name="line-264"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-265"></a><span class="hs-comment">--</span><span>
</span><a name="line-266"></a><span class="hs-comment">-- This is: &quot;pushes are effectively idempotent&quot;</span><span>
</span><a name="line-267"></a><span class="hs-comment">-- (using some &quot;generic&quot; joining of `f`s)</span><span>
</span><a name="line-268"></a><span class="hs-comment">--</span><span>
</span><a name="line-269"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-270"></a><span class="hs-comment">--   push  :: forall (a :: c). f (g a) -&gt; f (g (f a))</span><span>
</span><a name="line-271"></a><span class="hs-comment">--   joinf :: forall (a :: c). f (f a) -&gt; f a</span><span>
</span><a name="line-272"></a><span class="hs-comment">--</span><span>
</span><a name="line-273"></a><span class="hs-comment">--   push . push                :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))</span><span>
</span><a name="line-274"></a><span class="hs-comment">--   fmap (fmap joinf) . push . push :: f (g a) -&gt; f (g (f a))</span><span>
</span><a name="line-275"></a><span class="hs-comment">--</span><span>
</span><a name="line-276"></a><span class="hs-comment">--   fmap (fmap joinf) . push . push == push</span><span>
</span><a name="line-277"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-278"></a><span class="hs-comment">--</span><span>
</span><a name="line-279"></a><span class="hs-comment">-- This is: &quot;pushes are effectively idempotent&quot;</span><span>
</span><a name="line-280"></a><span class="hs-comment">-- (using some &quot;generic&quot; duplication of `f`'s)</span><span>
</span><a name="line-281"></a><span class="hs-comment">--</span><span>
</span><a name="line-282"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-283"></a><span class="hs-comment">--   push       :: forall (a :: c). f (g a) -&gt; f (g (f a))</span><span>
</span><a name="line-284"></a><span class="hs-comment">--   duplicatef :: forall (a :: c). f a -&gt; f (f a)</span><span>
</span><a name="line-285"></a><span class="hs-comment">--</span><span>
</span><a name="line-286"></a><span class="hs-comment">--   push . push                :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))</span><span>
</span><a name="line-287"></a><span class="hs-comment">--   fmap (fmap duplicatef) . push      :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))</span><span>
</span><a name="line-288"></a><span class="hs-comment">--</span><span>
</span><a name="line-289"></a><span class="hs-comment">--   fmap (fmap duplicatef) . push == push . push</span><span>
</span><a name="line-290"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-291"></a><span class="hs-comment">--</span><span>
</span><a name="line-292"></a><span class="hs-identifier">effectiveIdempotencePush</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-293"></a><a name="effectiveIdempotencePush"><a href="Data.Bidistributable.html#effectiveIdempotencePush"><span class="hs-identifier">effectiveIdempotencePush</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-294"></a><span>
</span><a name="line-295"></a><span>
</span><a name="line-296"></a><span>
</span><a name="line-297"></a><span class="hs-comment">-- | I believe that the weakest version is a duplicate that is injective?</span><span>
</span><a name="line-298"></a><span class="hs-comment">--</span><span>
</span><a name="line-299"></a><span class="hs-comment">-- Hmm, suppose we are within a context. This context is composable with itself.</span><span>
</span><a name="line-300"></a><span class="hs-comment">--</span><span>
</span><a name="line-301"></a><span class="hs-comment">-- - We want any &lt;-&gt; 1, which is equivalent to having 2 &lt;-&gt; 1.</span><span>
</span><a name="line-302"></a><span class="hs-comment">-- - We want this to be a natural transformation.</span><span>
</span><a name="line-303"></a><span class="hs-comment">--   * Ahh, what if we had: f (f a) -&gt; Maybe (f a)</span><span>
</span><a name="line-304"></a><span class="hs-comment">--   * Then, we could define the other mappings to match it so that it's always Just.</span><span>
</span><a name="line-305"></a><span class="hs-comment">--</span><span>
</span><a name="line-306"></a><span class="hs-comment">-- Regardless, we want to be able to show that the additional compositions provided by pushes are trivial.</span><span>
</span><a name="line-307"></a><span class="hs-identifier">weakestVersionDuplicate</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-308"></a><a name="weakestVersionDuplicate"><a href="Data.Bidistributable.html#weakestVersionDuplicate"><span class="hs-identifier">weakestVersionDuplicate</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-309"></a><span>
</span><a name="line-310"></a><span>
</span><a name="line-311"></a><span class="hs-comment">-- | Really, we probably want to have this property on the left as well, namely:</span><span>
</span><a name="line-312"></a><span class="hs-comment">-- partitioning an already partitioned functor only adds a trivial layer, since the functor has already been partitioned.</span><span>
</span><a name="line-313"></a><span class="hs-comment">--</span><span>
</span><a name="line-314"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-315"></a><span class="hs-comment">--   partition :: f (g a)  -&gt; f (f (g a))</span><span>
</span><a name="line-316"></a><span class="hs-comment">--   fmap partition . partition = fmap puref . partition</span><span>
</span><a name="line-317"></a><span class="hs-comment">--   fmap extract . fmap partition . partition = partition</span><span>
</span><a name="line-318"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-319"></a><span class="hs-comment">--</span><span>
</span><a name="line-320"></a><span class="hs-identifier">leftPartitionProperty</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-321"></a><a name="leftPartitionProperty"><a href="Data.Bidistributable.html#leftPartitionProperty"><span class="hs-identifier">leftPartitionProperty</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-322"></a><span>
</span><a name="line-323"></a><span>
</span><a name="line-324"></a><span class="hs-comment">-- To have everything be pushed/pulled through the (f . g) `joint`, we require that pushing/pulling are idempotent in some way.</span><span>
</span><a name="line-325"></a><span class="hs-comment">--</span><span>
</span><a name="line-326"></a><span class="hs-comment">-- The question is, how can we most abstractly represent that these actions are idempotent?</span><span>
</span><a name="line-327"></a><span class="hs-comment">--</span><span>
</span><a name="line-328"></a><span class="hs-comment">-- We don't necessarily have an equality or other properties of these functors.</span><span>
</span><a name="line-329"></a><span class="hs-comment">--</span><span>
</span><a name="line-330"></a><span class="hs-comment">-- Our answer is that the action of a second push or pull is a so-called &quot;least action&quot;:</span><span>
</span><a name="line-331"></a><span class="hs-comment">--</span><span>
</span><a name="line-332"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-333"></a><span class="hs-comment">--   push  :: forall (a :: c). f (g a) -&gt; f (g (f a))</span><span>
</span><a name="line-334"></a><span class="hs-comment">--   push . push                :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))</span><span>
</span><a name="line-335"></a><span class="hs-comment">--   push . push = l_push . push</span><span>
</span><a name="line-336"></a><span class="hs-comment">--   l_push :: forall (a :: c). f (g (f a)) -&gt; f (g (f (f a)))</span><span>
</span><a name="line-337"></a><span class="hs-comment">--     l_push is a least action from f (g (f a)) -&gt; f (g (f (f a)))</span><span>
</span><a name="line-338"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-339"></a><span class="hs-comment">--</span><span>
</span><a name="line-340"></a><span class="hs-identifier">leastActionExhaustivity</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-341"></a><a name="leastActionExhaustivity"><a href="Data.Bidistributable.html#leastActionExhaustivity"><span class="hs-identifier">leastActionExhaustivity</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-342"></a><span>
</span><a name="line-343"></a><span>
</span><a name="line-344"></a><span class="hs-comment">-- We want to have the least action done possible between those two compositions of functors.</span><span>
</span><a name="line-345"></a><span class="hs-comment">--</span><span>
</span><a name="line-346"></a><span class="hs-comment">-- Specifically, we want the least _left_ action.</span><span>
</span><a name="line-347"></a><span class="hs-comment">--</span><span>
</span><a name="line-348"></a><span class="hs-comment">--</span><span>
</span><a name="line-349"></a><span class="hs-comment">-- What makes an action least?</span><span>
</span><a name="line-350"></a><span class="hs-comment">--</span><span>
</span><a name="line-351"></a><span class="hs-comment">-- Well, I think that @(return :: forall (a :: c). a -&gt; f a)@ is a least action since there's no room for it to add more than the minimum amount of f's structure.</span><span>
</span><a name="line-352"></a><span class="hs-comment">--</span><span>
</span><a name="line-353"></a><span class="hs-comment">-- Ahhhh, if that doesn't exist, then the least amount of f's structure you could add would be:</span><span>
</span><a name="line-354"></a><span class="hs-comment">--</span><span>
</span><a name="line-355"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-356"></a><span class="hs-comment">--    (duplicate :: forall (a :: c). f a -&gt; f (f a))</span><span>
</span><a name="line-357"></a><span class="hs-comment">--  after that, it would be:</span><span>
</span><a name="line-358"></a><span class="hs-comment">--    (_         :: g (f a) -&gt; g (f (f a)))</span><span>
</span><a name="line-359"></a><span class="hs-comment">--  and finally, after that, it would be:</span><span>
</span><a name="line-360"></a><span class="hs-comment">--    (_         :: f (g (f a)) -&gt; f (g (f (f a))))</span><span>
</span><a name="line-361"></a><span class="hs-comment">--  But we want it to be independent of g's action, so we restrict our options to (return) and (duplicate).</span><span>
</span><a name="line-362"></a><span class="hs-comment">--    finally, since (return, fmap return :: f a -&gt; f (f a)), we may be able to restrict ourselves to needing duplicate.</span><span>
</span><a name="line-363"></a><span class="hs-comment">--      return . return == fmap return . return?</span><span>
</span><a name="line-364"></a><span class="hs-comment">--      fmap return . return == (&gt;&gt;= return . return) . return == \x -&gt; (return x &gt;&gt;= (return . return)) == \x -&gt; (return . return) x == return . return</span><span>
</span><a name="line-365"></a><span class="hs-comment">--      Yes, QED</span><span>
</span><a name="line-366"></a><span class="hs-comment">--  let's take the action to be duplicate.</span><span>
</span><a name="line-367"></a><span class="hs-comment">--  now, we want it to be:</span><span>
</span><a name="line-368"></a><span class="hs-comment">--    duplicate . duplicate = fmap duplicate . duplicate :: f a -&gt; f (f (f a))</span><span>
</span><a name="line-369"></a><span class="hs-comment">--  that is, the duplicates commute.</span><span>
</span><a name="line-370"></a><span class="hs-comment">--  actually, if the duplicates commute then we don't have an original, e.g. f a -&gt; f (f a), the original context could be left, right, or both.</span><span>
</span><a name="line-371"></a><span class="hs-comment">--</span><span>
</span><a name="line-372"></a><span class="hs-comment">--  what happens here, is that if it goes left, then (duplicate . duplicate) sends it all the way to the left and (fmap f . duplicate) does as well</span><span>
</span><a name="line-373"></a><span class="hs-comment">--                             if it goes right, then (duplicate . duplicate) sinds it to the right and (so does fmap f . duplicate)</span><span>
</span><a name="line-374"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-375"></a><span class="hs-comment">--</span><span>
</span><a name="line-376"></a><span class="hs-identifier">leastLeftAction</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-377"></a><a name="leastLeftAction"><a href="Data.Bidistributable.html#leastLeftAction"><span class="hs-identifier">leastLeftAction</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-378"></a><span>
</span><a name="line-379"></a><span>
</span><a name="line-380"></a><span class="hs-comment">--       ok, back to basics:</span><span>
</span><a name="line-381"></a><span class="hs-comment">--         push :: f (g a) -&gt; f (g (f a))</span><span>
</span><a name="line-382"></a><span class="hs-comment">--         push . push :: f (g a) -&gt; f (g (f (f a)))</span><span>
</span><a name="line-383"></a><span class="hs-comment">--       we want (push . push) to be (tt . push)</span><span>
</span><a name="line-384"></a><span class="hs-comment">--       tt :: f (g (f a)) -&gt; f (g (f (f a)))</span><span>
</span><a name="line-385"></a><span class="hs-comment">--       we want this f             ^ to be as close to trivial as possible. (I believe that it may be an isomorphism?)</span><span>
</span><a name="line-386"></a><span class="hs-comment">--       how can we tell how trivial it is?</span><span>
</span><a name="line-387"></a><span class="hs-comment">--         well consider:</span><span>
</span><a name="line-388"></a><span class="hs-comment">--           fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><span>
</span><a name="line-389"></a><span class="hs-comment">--           fmap :: (a -&gt; f a) -&gt; f a -&gt; f (f a)</span><span>
</span><a name="line-390"></a><span class="hs-comment">--           fmap :: (f a -&gt; f (f a)) -&gt; f (g (f a)) -&gt; f (g (f (f a)))</span><span>
</span><a name="line-391"></a><span class="hs-comment">--                        ^</span><span>
</span><a name="line-392"></a><span class="hs-comment">--             this is the one</span><span>
</span><a name="line-393"></a><span>
</span><a name="line-394"></a><span class="hs-comment">--             one2 :: f (g (f a)) -&gt; f (g (f (f a)))</span><span>
</span><a name="line-395"></a><span class="hs-comment">--             we want the left one in (f (f a)) to be trivial.</span><span>
</span><a name="line-396"></a><span class="hs-comment">--             for example:</span><span>
</span><a name="line-397"></a><span class="hs-comment">--               one2 . one2 == fmap return . one2</span><span>
</span><a name="line-398"></a><span>
</span><a name="line-399"></a><span class="hs-comment">--           fmap :: (g (f a) -&gt; g (f (f a))) -&gt; f (g (f a)) -&gt; f (g (f (f a)))</span><span>
</span><a name="line-400"></a><span class="hs-comment">--           fmap :: (g a -&gt; f (g a)) -&gt; f (g a) -&gt; f (f (g a))</span><span>
</span><a name="line-401"></a><span class="hs-comment">--             f (g a) -&gt; f (f (g a)) -&gt; f (f (f (g a)))</span><span>
</span><a name="line-402"></a><span class="hs-comment">--             partition :: f (g a) -&gt; f (f (g a))</span><span>
</span><a name="line-403"></a><span class="hs-comment">--                          ^          ^  \individual partitioned sets</span><span>
</span><a name="line-404"></a><span class="hs-comment">--                           \          \set of partitions</span><span>
</span><a name="line-405"></a><span class="hs-comment">--                            \original set</span><span>
</span><a name="line-406"></a><span class="hs-comment">--             fmap partition . partition :: f (g a) -&gt; f (f (f (g a)))</span><span>
</span><a name="line-407"></a><span class="hs-comment">--                                                  ^  ^  \the new partitioned sets</span><span>
</span><a name="line-408"></a><span class="hs-comment">--                                                   \  \the new set of partitions</span><span>
</span><a name="line-409"></a><span class="hs-comment">--                                                    \the set of new sets of partitions</span><span>
</span><a name="line-410"></a><span>
</span><a name="line-411"></a><span class="hs-comment">--             two3' :: f (f (g a)) -&gt; f (f (f (g a)))</span><span>
</span><a name="line-412"></a><span class="hs-comment">--               we want the middle `f` in (f (f (f (g a)))) to be trivial</span><span>
</span><a name="line-413"></a><span class="hs-comment">--             two3' = fmap (two3 :: f (g a) -&gt; f (f (g a)))</span><span>
</span><a name="line-414"></a><span class="hs-comment">--               we want the right `f` in (f (f (g a))) to be trivial</span><span>
</span><a name="line-415"></a><span>
</span><a name="line-416"></a><span class="hs-comment">--             one2 :: f (g (f a)) -&gt; f (g (f (f a))) (left  in (f . f) is trivial)</span><span>
</span><a name="line-417"></a><span class="hs-comment">--                                          ^ at this point, the only resources we have are from the outer (f (g _))</span><span>
</span><a name="line-418"></a><span class="hs-comment">--                                            this means that we can reduce a solution to a function of the type:</span><span>
</span><a name="line-419"></a><span class="hs-comment">--                                            forall a. f (g a) -&gt; f (g (f a))</span><span>
</span><a name="line-420"></a><span class="hs-comment">--                                            (pushover :: f (f (g a)) -&gt; f (g (f a))) . (two3 :: f a -&gt; f (f a)))</span><span>
</span><a name="line-421"></a><span class="hs-comment">--                                            (since this `f` cannot depend on (f a) for it to be trivial)</span><span>
</span><a name="line-422"></a><span class="hs-comment">--             two3 :: f (g a)     -&gt; f (f (g a))     (right in (f . f) is trivial)</span><span>
</span><a name="line-423"></a><span class="hs-comment">--                                       ^ at this point, the only resources we have are from the outer (f _)</span><span>
</span><a name="line-424"></a><span class="hs-comment">--                                       this means that we may be able to reduce a solution to a function of the type:</span><span>
</span><a name="line-425"></a><span class="hs-comment">--                                       forall a. f a -&gt; f (f a)</span><span>
</span><a name="line-426"></a><span class="hs-comment">--                                                      ^ trivial</span><span>
</span><a name="line-427"></a><span class="hs-comment">--                                       two3 . two3 == fmap two3 . two3</span><span>
</span><a name="line-428"></a><span class="hs-comment">--                                       Hmm, if we say that the left side being trivial means that it cannot depend on f, and so it must be equal to (fmap _), then we get that:</span><span>
</span><a name="line-429"></a><span class="hs-comment">--                                         (fmap return :: f a -&gt; f (f a))</span><span>
</span><a name="line-430"></a><span class="hs-comment">--                                       with the new requirement:</span><span>
</span><a name="line-431"></a><span class="hs-comment">--                                         fmap return . return == return . return</span><span>
</span><a name="line-432"></a><span>
</span><a name="line-433"></a><span class="hs-comment">--                                       (since this `f` cannot depend on (f a) for it to be trivial)</span><span>
</span><a name="line-434"></a><span class="hs-comment">--               (when linearized (under vertical composition), these are commutative)</span><span>
</span><a name="line-435"></a><span class="hs-comment">--               I believe that since (pushover :: f (f (g a)) -&gt; f (g (f a))) is a natural transformation, we may be able to show that it preserves the triviality?</span><span>
</span><a name="line-436"></a><span>
</span><a name="line-437"></a><span class="hs-comment">--             return :: a -&gt; f a</span><span>
</span><a name="line-438"></a><span class="hs-comment">--             fmap return :: f (g a) -&gt; f (f (g a))</span><span>
</span><a name="line-439"></a><span class="hs-comment">--             fmap (fmap return) . partition == fmap partition . partition :: f (g a) -&gt; f (f (f (g a)))</span><span>
</span><a name="line-440"></a><span>
</span><a name="line-441"></a><span class="hs-comment">--             fmap (fmap return) :: f (g a) -&gt; f (g (f a))</span><span>
</span><a name="line-442"></a><span class="hs-comment">--             fmap (fmap return) . push == push . push :: f (g a) -&gt; f (g (f (f a)))</span><span>
</span><a name="line-443"></a><span>
</span><a name="line-444"></a><span class="hs-comment">--             Joined f g</span><span>
</span><a name="line-445"></a><span class="hs-comment">--               JoinedL f =&gt; (forall g. Functor g =&gt; Joined f g)</span><span>
</span><a name="line-446"></a><span class="hs-comment">--               JoinedR g =&gt; (forall f. (Functor f, Pointed f) =&gt; Joined f g)</span><span>
</span><a name="line-447"></a><span class="hs-comment">--             Functor f, Functor g</span><span>
</span><a name="line-448"></a><span class="hs-comment">--             Natural transformations:</span><span>
</span><a name="line-449"></a><span class="hs-comment">--               partition :: f (g a)     -&gt; f (f (g a))</span><span>
</span><a name="line-450"></a><span class="hs-comment">--               pushover  :: f (f (g a)) -&gt; f (g (f a))</span><span>
</span><a name="line-451"></a><span class="hs-comment">--               return    :: a -&gt; f a</span><span>
</span><a name="line-452"></a><span>
</span><a name="line-453"></a><span class="hs-comment">--             partition . pushover == push :: f (g a) -&gt; f (g (f a))</span><span>
</span><a name="line-454"></a><span class="hs-comment">--             fmap (fmap return) . partition == fmap partition . partition</span><span>
</span><a name="line-455"></a><span class="hs-comment">--             fmap (fmap return) . push == push . push</span><span>
</span><a name="line-456"></a><span class="hs-comment">--             fmap return == return . return</span><span>
</span><a name="line-457"></a><span>
</span><a name="line-458"></a><span class="hs-comment">--             Joined2 f g where -- to convert between the two, use the curry/uncurry functors/natural transformations</span><span>
</span><a name="line-459"></a><span class="hs-comment">--               partition2 :: f (g (a, b)) -&gt; f (f (g (a, b)))</span><span>
</span><a name="line-460"></a><span class="hs-comment">--               pushover2  :: f (f (g (a, b))) -&gt; f (g (f a) (f b))</span><span>
</span><a name="line-461"></a><span class="hs-comment">--               return     :: a -&gt; f a</span><span>
</span><a name="line-462"></a><span>
</span><a name="line-463"></a><span class="hs-comment">--             instance Joined2 [] Either where</span><span>
</span><a name="line-464"></a><span class="hs-comment">--               partition2 :: [Either a b] -&gt; [[Either a b]]</span><span>
</span><a name="line-465"></a><span class="hs-comment">--               partition2 = groupBy ((==) `on` isLeft)</span><span>
</span><a name="line-466"></a><span>
</span><a name="line-467"></a><span class="hs-comment">--               pushover2  :: [[Either a b]] -&gt; [Either [a] [b]]</span><span>
</span><a name="line-468"></a><span class="hs-comment">--               pushover2 = fmap (skipNull (\(x:xs) -&gt; if isLeft x then Left (fromLeft &lt;$&gt; (x:xs)) else Right (fromRight &lt;$&gt; (x:xs))))</span><span>
</span><a name="line-469"></a><span>
</span><a name="line-470"></a><span class="hs-comment">--               return     :: a -&gt; [a]</span><span>
</span><a name="line-471"></a><span class="hs-comment">--               return x = [x]</span><span>
</span><a name="line-472"></a><span>
</span><a name="line-473"></a><span class="hs-comment">--             there is a canonical instance for foldable/unfoldable &amp;&amp; g + coloring</span><span>
</span><a name="line-474"></a><span class="hs-comment">--               you color the elements of (g a) with some valid coloring when considering some sort of adjacency on (f (g a))</span><span>
</span><a name="line-475"></a><span class="hs-comment">--                 this forms the partition</span><span>
</span><a name="line-476"></a><span class="hs-comment">--               you use the adjacency to cleanly form the pushover (the adjacency is on the endpoints of where f includes (g a) in (f (g a))</span><span>
</span><a name="line-477"></a><span>
</span><a name="line-478"></a><span class="hs-comment">--                 that is, the coloring allows us to take the structure of f and since we have a connected component, we can extract this connected component</span><span>
</span><a name="line-479"></a><span class="hs-comment">--                 we can then push this connected component cleanly inside of g</span><span>
</span><a name="line-480"></a><span class="hs-comment">--                   f (g a) -&gt; f (g_path a -&gt; f a, g a)</span><span>
</span><a name="line-481"></a><span class="hs-comment">--                   fmap (uncurry fmap) :: f (a -&gt; f a, g a) -&gt; f (g (f a))</span><span>
</span><a name="line-482"></a><span class="hs-comment">--                in other words, each connected component of (f (g a)) forms a skeleton</span><span>
</span><a name="line-483"></a><span class="hs-comment">--                  f (f a) -&gt; f ({a} -&gt; f a, {a})</span><span>
</span><a name="line-484"></a><span class="hs-comment">--                  f (f a) -&gt; f ((a -&gt; Set) -&gt; f a)</span><span>
</span><a name="line-485"></a><span class="hs-comment">--                   f (g a) -&gt; f ((a -&gt; Set) -&gt; g a)</span><span>
</span><a name="line-486"></a><span class="hs-comment">--                   \(x :: f (g a)) -&gt; ((f (g a) -&gt; f ((a -&gt; Set) -&gt; g a)) x) &lt;*&gt; (fmap (fmap yoneda) x :: f (g (a -&gt; Set)))</span><span>
</span><a name="line-487"></a><span>
</span><a name="line-488"></a><span class="hs-comment">--                  ((h_a :: a -&gt; Set) -&gt; f a) &lt;-&gt; f a</span><span>
</span><a name="line-489"></a><span class="hs-comment">--                  ((h_(f a) :: f a -&gt; Set) -&gt; f (f a)) &lt;-&gt; f (f a)</span><span>
</span><a name="line-490"></a><span>
</span><a name="line-491"></a><span class="hs-comment">--                ergo, this works iff `f` has ((&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b) and the background category is locally small</span><span>
</span><a name="line-492"></a><span>
</span><a name="line-493"></a><span class="hs-comment">--             another way to look at this is we have some polyfold: polyFoldr :: (forall u. Foldable u =&gt; u a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span><span>
</span><a name="line-494"></a><span class="hs-comment">--               g has zipWith</span><span>
</span><a name="line-495"></a><span class="hs-comment">--               f is pointed, we have a semigroup over (f a)</span><span>
</span><a name="line-496"></a><span class="hs-comment">--               f has polyfold</span><span>
</span><a name="line-497"></a><span class="hs-comment">--               the polyfold on f gives a view into the internal sctructure, aka a partition</span><span>
</span><a name="line-498"></a><span class="hs-comment">--               fmap (fmap (fmap return)) :: f (f (g a)) -&gt; f (f (g (f a)))</span><span>
</span><a name="line-499"></a><span class="hs-comment">--                 point the elements of `g`</span><span>
</span><a name="line-500"></a><span class="hs-comment">--               ~polyfold (polyzip (&lt;&gt;))~ :: f (f (g (f a))) -&gt; f (g (f a))</span><span>
</span><a name="line-501"></a><span class="hs-comment">--                 fold the inner layer of `f` zipping (g (f a))'s along the lines of the builders for these (f (g (f a)))'s</span><span>
</span><a name="line-502"></a><span>
</span><a name="line-503"></a><span>
</span><a name="line-504"></a><span class="hs-comment">--               unfoldr :: Functor g =&gt; (forall u. Foldable u =&gt; a -&gt; u a) -&gt; g a -&gt; g (t a</span><span>
</span><a name="line-505"></a><span class="hs-comment">--               if `f` is PolyFoldable and `g` is pointable: g a -&gt; ((t :: A) -&gt; g (t :: A), a :: A)</span><span>
</span><a name="line-506"></a><span class="hs-comment">--               then we can</span><span>
</span><a name="line-507"></a><span>
</span><a name="line-508"></a><span class="hs-comment">--             (partition) maps the original set to a set of partitions (the outer set, the universe set) and the partitions (the inner set)</span><span>
</span><a name="line-509"></a><span class="hs-comment">--             (fmap partition . partition) maps the original set to the set of sets of partitions (the left set, the universe set) the singleton sets of the only partition in the subset (the middle set, singletons of partitions) the partitions (the right set)</span><span>
</span><a name="line-510"></a><span class="hs-comment">--           So, what we want is to prove that the middle (f) is trivial (and possibly that (foldr ..) (_ :: f (g a)) is equal to (foldr (foldr ..)..) (_ :: f (f (g a))))</span><span>
</span><a name="line-511"></a><span class="hs-comment">--           Question: can this depend on (g a)? Well yes, the partition can depend on the values of type (g a), e.g. isLeft</span><span>
</span><a name="line-512"></a><span>
</span><a name="line-513"></a><span>
</span><a name="line-514"></a><span class="hs-comment">-- | Question: can we linearize this?</span><span>
</span><a name="line-515"></a><span class="hs-comment">--</span><span>
</span><a name="line-516"></a><span class="hs-comment">-- Yes, we just map words of functions of type @f (g a) -&gt; f (f (g a))@ using the following patterns:</span><span>
</span><a name="line-517"></a><span class="hs-comment">--</span><span>
</span><a name="line-518"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-519"></a><span class="hs-comment">--  f0</span><span>
</span><a name="line-520"></a><span class="hs-comment">--  fmap f0 . f1</span><span>
</span><a name="line-521"></a><span class="hs-comment">--  fmap (fmap f0) . fmap f1 . f2</span><span>
</span><a name="line-522"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-523"></a><span class="hs-comment">--</span><span>
</span><a name="line-524"></a><span class="hs-comment">-- Quality preserves the lengths of words, because the words have unique types.</span><span>
</span><a name="line-525"></a><span class="hs-comment">--</span><span>
</span><a name="line-526"></a><span class="hs-comment">-- We want that (@p=partition@):</span><span>
</span><a name="line-527"></a><span class="hs-comment">--</span><span>
</span><a name="line-528"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-529"></a><span class="hs-comment">-- &quot;pp&quot; -&gt; &quot;_p&quot;</span><span>
</span><a name="line-530"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-531"></a><span class="hs-comment">--</span><span>
</span><a name="line-532"></a><span class="hs-comment">-- Now, what is this blank? Hmm.</span><span>
</span><a name="line-533"></a><span class="hs-comment">--</span><span>
</span><a name="line-534"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-535"></a><span class="hs-comment">--  eta(x) :: f (g (f x)) -&gt; f (g (f (f x)))</span><span>
</span><a name="line-536"></a><span class="hs-comment">--  fn :: x -&gt; y =&gt; eta(y) . f (g (f x)) == f (g (f (f x))) . eta(x)</span><span>
</span><a name="line-537"></a><span class="hs-comment">--</span><span>
</span><a name="line-538"></a><span class="hs-comment">--  eta^(-1)(x) . eta(y) . f (g (f x)) == f (g (f (f x)))</span><span>
</span><a name="line-539"></a><span class="hs-comment">--  eta^(-1)(x) . eta(y) . f (g x) == f (f (g x))</span><span>
</span><a name="line-540"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-541"></a><span class="hs-comment">--</span><span>
</span><a name="line-542"></a><span class="hs-comment">-- We want the &quot;real&quot; one to stay fixed on the leftmost of the compositions of `f`s.</span><span>
</span><a name="line-543"></a><span class="hs-identifier">linearizationQuestion</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-544"></a><a name="linearizationQuestion"><a href="Data.Bidistributable.html#linearizationQuestion"><span class="hs-identifier">linearizationQuestion</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-545"></a><span>
</span><a name="line-546"></a><span>
</span><a name="line-547"></a><span class="hs-comment">-- Going the other way, @f (g a) -&gt; f (f (g a))@.</span><span>
</span><a name="line-548"></a><span class="hs-comment">--</span><span>
</span><a name="line-549"></a><span class="hs-comment">-- For this one, we want:</span><span>
</span><a name="line-550"></a><span class="hs-comment">--</span><span>
</span><a name="line-551"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-552"></a><span class="hs-comment">--  partition :: forall (a :: c). f (g a) -&gt; f (f (g a))</span><span>
</span><a name="line-553"></a><span class="hs-comment">--  fmap partition . partition :: forall (a :: c). f (g a) -&gt; f (f (f (g a)))</span><span>
</span><a name="line-554"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-555"></a><span class="hs-comment">--</span><span>
</span><a name="line-556"></a><span class="hs-comment">-- In other words, the new rightmost layer should be a least action.</span><span>
</span><a name="line-557"></a><span class="hs-comment">--</span><span>
</span><a name="line-558"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-559"></a><span class="hs-comment">--  fmap l_partition . partition :: forall (a :: c). f (g a) -&gt; f (f (f (g a)))</span><span>
</span><a name="line-560"></a><span class="hs-comment">--  l_partition :: forall (a :: c). f (f (g a)) -&gt; f (f (f (g a)))</span><span>
</span><a name="line-561"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-562"></a><span class="hs-comment">--</span><span>
</span><a name="line-563"></a><span class="hs-comment">-- The least amount of structure you could add (on the right) would be:</span><span>
</span><a name="line-564"></a><span class="hs-comment">--</span><span>
</span><a name="line-565"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-566"></a><span class="hs-comment">--  (returnG :: forall a. g a -&gt; f (g a))</span><span>
</span><a name="line-567"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-568"></a><span class="hs-comment">--</span><span>
</span><a name="line-569"></a><span class="hs-comment">-- After that:</span><span>
</span><a name="line-570"></a><span class="hs-comment">--</span><span>
</span><a name="line-571"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-572"></a><span class="hs-comment">--  (duplicateG :: forall a. f (g a) -&gt; f (f (g a)))</span><span>
</span><a name="line-573"></a><span class="hs-comment">--</span><span>
</span><a name="line-574"></a><span class="hs-comment">--  fmap returnG :: forall a. f (g a) -&gt; f (f (g a))</span><span>
</span><a name="line-575"></a><span class="hs-comment">--</span><span>
</span><a name="line-576"></a><span class="hs-comment">--  fmap returnG . returnG :: g a -&gt; f (f (g a))</span><span>
</span><a name="line-577"></a><span class="hs-comment">--</span><span>
</span><a name="line-578"></a><span class="hs-comment">--  fmap (fmap returnG) . fmap returnG :: f (g a) -&gt; f (f (f (g a)))</span><span>
</span><a name="line-579"></a><span class="hs-comment">--</span><span>
</span><a name="line-580"></a><span class="hs-comment">--  fmap^n returnG :: f^n (g a) -&gt; f^(n+1) (g a)</span><span>
</span><a name="line-581"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-582"></a><span class="hs-comment">--</span><span>
</span><a name="line-583"></a><span class="hs-comment">--</span><span>
</span><a name="line-584"></a><span class="hs-comment">-- Or, do we want the free action for this? I'm not sure.</span><span>
</span><a name="line-585"></a><span class="hs-comment">--</span><span>
</span><a name="line-586"></a><span class="hs-comment">-- The least we can do to move from @(f a -&gt; f b)@ is the method that preserves the most we can using the definition of the functor:</span><span>
</span><a name="line-587"></a><span class="hs-comment">--</span><span>
</span><a name="line-588"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-589"></a><span class="hs-comment">--  ((a -&gt; b) -&gt; (f a -&gt; f b))</span><span>
</span><a name="line-590"></a><span class="hs-comment">--</span><span>
</span><a name="line-591"></a><span class="hs-comment">--  Thus:</span><span>
</span><a name="line-592"></a><span class="hs-comment">--</span><span>
</span><a name="line-593"></a><span class="hs-comment">--  l_push = fmap (_ :: forall (a :: c). g (f a) -&gt; g (f (f a)))</span><span>
</span><a name="line-594"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-595"></a><span class="hs-comment">--</span><span>
</span><a name="line-596"></a><span class="hs-identifier">goingTheOtherWayLeastActions</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-597"></a><a name="goingTheOtherWayLeastActions"><a href="Data.Bidistributable.html#goingTheOtherWayLeastActions"><span class="hs-identifier">goingTheOtherWayLeastActions</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-598"></a><span>
</span><a name="line-599"></a><span>
</span><a name="line-600"></a><span class="hs-comment">-- | Suppose we have some natural transformation: @f . g -&gt; f . h@.</span><span>
</span><a name="line-601"></a><span class="hs-comment">--   Is this equivalent to some natural transformation: @g -&gt; h@, up to bijection?</span><span>
</span><a name="line-602"></a><span class="hs-comment">--</span><span>
</span><a name="line-603"></a><span class="hs-comment">--</span><span>
</span><a name="line-604"></a><span class="hs-comment">-- One way, take @f@'s identity natural transformation @id_f :: f -&gt; f@.</span><span>
</span><a name="line-605"></a><span class="hs-comment">-- Then the left composition with @(g -&gt; h)@ is another natural transformation: @(f . g -&gt; f . h)@, and since @id_f@ is a bijection this is as well. Q.E.D.</span><span>
</span><a name="line-606"></a><span class="hs-comment">--</span><span>
</span><a name="line-607"></a><span class="hs-comment">-- Another way, we have some natural transformation from @(f . g -&gt; f . h)@.</span><span>
</span><a name="line-608"></a><span class="hs-comment">--</span><span>
</span><a name="line-609"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-610"></a><span class="hs-comment">--     eta is a natural transformation from (f . g) to (f . h).</span><span>
</span><a name="line-611"></a><span class="hs-comment">--     X :: C =&gt; eta_X :: (f . g) x -&gt; (f . h) x</span><span>
</span><a name="line-612"></a><span class="hs-comment">--     X :: C =&gt; beta_X :: g x -&gt; h x</span><span>
</span><a name="line-613"></a><span class="hs-comment">--     eta_Y . (f . g) fn = (f . h) fn . eta_X</span><span>
</span><a name="line-614"></a><span class="hs-comment">--       fn :: X -&gt; Y</span><span>
</span><a name="line-615"></a><span class="hs-comment">--</span><span>
</span><a name="line-616"></a><span class="hs-comment">--     eta_(beta_Y) . (f . g) fn = (f . h) fn . eta_(beta_X)</span><span>
</span><a name="line-617"></a><span class="hs-comment">--</span><span>
</span><a name="line-618"></a><span class="hs-comment">--     eta_X :: f x -&gt; f x</span><span>
</span><a name="line-619"></a><span class="hs-comment">--     beta_X :: g x -&gt; h x</span><span>
</span><a name="line-620"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-621"></a><span class="hs-comment">--</span><span>
</span><a name="line-622"></a><span class="hs-comment">-- Well, this suggests that we can only go the other way when we have a bijection from @(f . g)@ to @(f . h)@</span><span>
</span><a name="line-623"></a><span class="hs-comment">--</span><span>
</span><a name="line-624"></a><span class="hs-comment">-- Otherwise, we wouldn't be able to form bijections between @(eta_X :: (f . g) x -&gt; (f . h) x)@ and @(beta_X :: g x -&gt; h x)@.</span><span>
</span><a name="line-625"></a><span class="hs-comment">--</span><span>
</span><a name="line-626"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-627"></a><span class="hs-comment">--  eta . f . beta . f' == (id :: (f . h) x -&gt; (f . h) x) =&gt; f :: h x -&gt; (f . g) x, f' :: (f . h) x -&gt; g x</span><span>
</span><a name="line-628"></a><span class="hs-comment">--  beta . g . eta . g' == (id :: h x -&gt; h x) =&gt; g :: (f . h) x -&gt; g x, g' :: h x -&gt; (f . g) x</span><span>
</span><a name="line-629"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-630"></a><span class="hs-comment">--</span><span>
</span><a name="line-631"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-632"></a><span class="hs-comment">--  g == f . g</span><span>
</span><a name="line-633"></a><span class="hs-comment">--  g == f . h</span><span>
</span><a name="line-634"></a><span class="hs-comment">--  h == f . g</span><span>
</span><a name="line-635"></a><span class="hs-comment">--  h == f . h</span><span>
</span><a name="line-636"></a><span class="hs-comment">--  g == h</span><span>
</span><a name="line-637"></a><span class="hs-comment">--</span><span>
</span><a name="line-638"></a><span class="hs-comment">--  f == f . g</span><span>
</span><a name="line-639"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-640"></a><span class="hs-comment">--</span><span>
</span><a name="line-641"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-642"></a><span class="hs-comment">--  (g) must be a left identity of (f) under composition</span><span>
</span><a name="line-643"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-644"></a><span class="hs-comment">--</span><span>
</span><a name="line-645"></a><span class="hs-comment">--   Results:</span><span>
</span><a name="line-646"></a><span class="hs-comment">--</span><span>
</span><a name="line-647"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-648"></a><span class="hs-comment">--  An injective mapping from a natural transformation :: (g -&gt; h) to one :: (f . g -&gt; f . h) is trivial.</span><span>
</span><a name="line-649"></a><span class="hs-comment">--  An injective mapping from a natural transformation :: (f . g -&gt; f . h) to one :: (g -&gt; h) exists iff (g == h) and (f == f . g), i.e. (g) must be a left identity of (f) under composition.</span><span>
</span><a name="line-650"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-651"></a><span class="hs-comment">--</span><span>
</span><a name="line-652"></a><span class="hs-identifier">naturalTransformationUpToBijection</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-653"></a><a name="naturalTransformationUpToBijection"><a href="Data.Bidistributable.html#naturalTransformationUpToBijection"><span class="hs-identifier">naturalTransformationUpToBijection</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-654"></a><span>
</span><a name="line-655"></a><span>
</span><a name="line-656"></a><span class="hs-comment">-- | Question, is the limit of some functor inhabited? e.g.</span><span>
</span><a name="line-657"></a><span class="hs-comment">--</span><span>
</span><a name="line-658"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-659"></a><span class="hs-comment">--   The limit of Maybe is inhabited by:</span><span>
</span><a name="line-660"></a><span class="hs-comment">--     Nothing</span><span>
</span><a name="line-661"></a><span class="hs-comment">--     Just Nothing</span><span>
</span><a name="line-662"></a><span class="hs-comment">--     Just (Just Nothing)</span><span>
</span><a name="line-663"></a><span class="hs-comment">--     (the natural numbers)</span><span>
</span><a name="line-664"></a><span class="hs-comment">--   The limit of (\x -&gt; (a, x)) has exactly one inhabitant:</span><span>
</span><a name="line-665"></a><span class="hs-comment">--     (a, (a, (a, (a, ..))))</span><span>
</span><a name="line-666"></a><span class="hs-comment">--     (a right-infinite list)</span><span>
</span><a name="line-667"></a><span class="hs-comment">--   The limit of (\x -&gt; Either a x) has the inhabitants:</span><span>
</span><a name="line-668"></a><span class="hs-comment">--     Left a</span><span>
</span><a name="line-669"></a><span class="hs-comment">--     Right (Left a)</span><span>
</span><a name="line-670"></a><span class="hs-comment">--     Right (Right (Left a)</span><span>
</span><a name="line-671"></a><span class="hs-comment">--     (the pair (Nat, a))</span><span>
</span><a name="line-672"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-673"></a><span class="hs-comment">--</span><span>
</span><a name="line-674"></a><span class="hs-comment">-- what about expressing the limit of pushes? That's probably something like:</span><span>
</span><a name="line-675"></a><span class="hs-comment">--</span><span>
</span><a name="line-676"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-677"></a><span class="hs-comment">--   f (g a) -&gt; f (g (Fix f a))</span><span>
</span><a name="line-678"></a><span class="hs-comment">--   no... hmmm</span><span>
</span><a name="line-679"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-680"></a><span class="hs-comment">--</span><span>
</span><a name="line-681"></a><span class="hs-identifier">functorLimitNotes</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-682"></a><a name="functorLimitNotes"><a href="Data.Bidistributable.html#functorLimitNotes"><span class="hs-identifier">functorLimitNotes</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-683"></a><span>
</span><a name="line-684"></a><span>
</span><a name="line-685"></a><span class="hs-comment">-- | Some notes on composing sequences of functors</span><span>
</span><a name="line-686"></a><span class="hs-comment">--</span><span>
</span><a name="line-687"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-688"></a><span class="hs-comment">-- f . g == f . g . f</span><span>
</span><a name="line-689"></a><span class="hs-comment">-- f . g == (f . g) . f == ((f . g) . f) . f == (((f . g) . f) . f) . f</span><span>
</span><a name="line-690"></a><span class="hs-comment">-- f . g == f . (f . g) == f . (f . (f . g)) == f . (f . (f . (f . g)))</span><span>
</span><a name="line-691"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-692"></a><span class="hs-comment">--</span><span>
</span><a name="line-693"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-694"></a><span class="hs-comment">-- a; a,b; a,b,a; a,b,a,b</span><span>
</span><a name="line-695"></a><span class="hs-comment">-- b; b,a; b,a,b; b,a,b,a</span><span>
</span><a name="line-696"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-697"></a><span class="hs-comment">--</span><span>
</span><a name="line-698"></a><span class="hs-identifier">functorCompositionNotes</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-699"></a><a name="functorCompositionNotes"><a href="Data.Bidistributable.html#functorCompositionNotes"><span class="hs-identifier">functorCompositionNotes</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-700"></a><span>
</span><a name="line-701"></a></pre></body></html>