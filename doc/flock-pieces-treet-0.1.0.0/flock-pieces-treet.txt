-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package flock-pieces-treet
@version 0.1.0.0

module Control.Monad.Trans.TreeT

-- | Algebraic notes:
--   
--   <pre>
--   -- f' = (f / g) * g'
--   -- f' = (f <i> g) * ((g </i> f) * f')
--   -- f' = (*) ((<i>) f g) ((*) ((</i>) g f) f')
--   -- f' = (f <tt>y</tt> g) <tt>x</tt> ((g <tt>y</tt> f) <tt>x</tt> f')
--   </pre>
--   
--   <pre>
--   f' x y f g = x (y f g) . x (y g f) $ f'
--   </pre>
--   
--   <pre>
--   -- g' = (g / f) * f'
--   -- g' = (g <i> f) * ((f </i> g) * g')
--   -- g' = (g <tt>y</tt> f) <tt>x</tt> ((f <tt>y</tt> g) <tt>x</tt> g')
--   </pre>
--   
--   <pre>
--   g' x y f g = x (y g f) . x (y f g) $ g'
--   </pre>
--   
--   <pre>
--   f' = (f <tt>y</tt> g) <tt>x</tt> g'
--   g' = (g <tt>y</tt> h) <tt>x</tt> h'
--   h' = (h <tt>y</tt> f) <tt>x</tt> f'
--   </pre>
--   
--   If <tt><tt>x</tt></tt> right-distributes over <tt><tt>y</tt></tt>:
--   
--   <pre>
--   f' = (f <tt>y</tt> g) <tt>x</tt> g' = (f <tt>y</tt> g') <tt>x</tt> (g <tt>y</tt> g')
--   g' = (g <tt>y</tt> h) <tt>x</tt> h' = (g <tt>y</tt> h') <tt>x</tt> (h <tt>y</tt> h')
--   h' = (h <tt>y</tt> f) <tt>x</tt> f' = (h <tt>y</tt> f') <tt>x</tt> (f <tt>y</tt> f')
--   
--   f' = (f <tt>y</tt> g) <tt>x</tt> g' = (f <tt>y</tt> g) <tt>x</tt> ((g <tt>y</tt> h) <tt>x</tt> ((h <tt>y</tt> f) <tt>x</tt> f'))
--   g' = (g <tt>y</tt> h) <tt>x</tt> h' = (g <tt>y</tt> h) <tt>x</tt> ((h <tt>y</tt> f) <tt>x</tt> ((f <tt>y</tt> g) <tt>x</tt> g'))
--   h' = (h <tt>y</tt> f) <tt>x</tt> f' = (h <tt>y</tt> f) <tt>x</tt> ((f <tt>y</tt> g) <tt>x</tt> ((g <tt>y</tt> h) <tt>x</tt> h'))
--   
--   f' = x (y f g) . x (y g f) $ f'
--   g' = x (y g f) . x (y f g) $ g'
--   
--   f' = x (y f g) g' = x (y f g) . x (y g h) . x (y h f) $ f'
--   g' = x (y g h) h' = x (y g h) . x (y h f) . x (y f g) $ g'
--   h' = x (y h f) f' = x (y h f) . x (y f g) . x (y g h) $ h'
--   
--   f' = x (y f g) g' = ((.) (x (y f g)) ((.) (x (y g h)) (x (y h f))) $ f'
--   g' = x (y g h) h' = x (y g h) . (x (y h f) . x (y f g)) $ g'
--   h' = x (y h f) f' = x (y h f) . (x (y f g) . x (y g h)) $ h'
--   </pre>
--   
--   <pre>
--   (.) :: cat b c -&gt; cat a b -&gt; cat a c
--   
--   (.) (x (y g h)) (x (y h f)) :: xygh b1 c1 -&gt; xyhf a1 b1 -&gt; ghf a1 c1
--   (.) (x (y h f)) (x (y f g)) :: xyhf b2 c2 -&gt; xyfg a2 b2 -&gt; hfg a2 c2
--   (.) (x (y f g)) (x (y g h)) :: xyfg b3 c3 -&gt; xygh a3 b3 -&gt; fgh a3 c3
--   
--   (.) (x (y f g)) :: xyfg c1 d1 -&gt; ghf a1 c1 -&gt; C1 a1 d1
--   (.) (x (y g h)) :: xygh c2 d2 -&gt; hfg a2 c2 -&gt; C2 a2 d2
--   (.) (x (y h f)) :: xyhf c3 d3 -&gt; fgh a3 c3 -&gt; C2 a3 d3
--   </pre>
--   
--   So <tt>x</tt> has to be at least a semigroupoid, to support
--   composition
--   
--   <pre>
--     furthermore, it has to lift all the pairs to a common category
--     furthermore, it has to be funtorial, to allow preservation of internal properties
--   y :: `f -&gt; `g -&gt; `(y f g)
--   y :: `g -&gt; `f -&gt; `(y g f)
--   </pre>
--   
--   <pre>
--   y :: `f -&gt; `g -&gt; `(y f g)
--   y :: `g -&gt; `h -&gt; `(y g h)
--   y :: `h -&gt; `f -&gt; `(y h f)
--   </pre>
algebraicNotes :: ()

-- | Algebraic examples:
--   
--   <pre>
--   La * Lb -&gt; La
--   
--   (La :*: Lb) a -&gt; La a
--   
--   (La -&gt; (La || Lb)) -&gt; (Lb -&gt; (La || Lb)) -&gt; (La -&gt; La - Lb)
--   
--   Suppose La &lt;= Lb
--   </pre>
--   
--   <pre>
--   A, B, A &amp;&amp; B, A || B, A * B, A + B
--   
--   Either A B
--   (A, B)
--   </pre>
algebraicExamples :: ()
considerLanguageCycle :: ()

-- | Thus we see that for languages based on <tt>(-&gt;)</tt>, aka
--   application, every property seems to hold on either <a>Tree</a> or
--   <a>Forest</a>:
--   
--   <ul>
--   <li>Because Tree is the combination of the Value language and the
--   Action language</li>
--   <li>Because ATree is the combination of the Semigroupoid language with
--   the Category language (ATree doesn't have identity, AForest does, even
--   though it contains ATree.)</li>
--   <li>OR because <tt>ATree</tt> is the product of <tt>(Category -
--   Identity)</tt> and <tt>Category</tt>..?</li>
--   <li>So all associtive-requiring properties hold for both and all
--   <tt>associative+identity</tt>-requiring properties only hold for
--   <tt>AForest</tt></li>
--   </ul>
--   
--   If this construction works, then I believe it may be "self-holding",
--   i.e. free: The primitives used to express it are exactly the
--   primitives needed to express it.
--   
--   If this works and forms an internally consistent language, then this
--   effectively adds a primitive form of implementation-agnostic,
--   decidable, recursion to Flock.
--   
--   It also allows the simple addition of Categories, Application, Type
--   hierarchies, etc. etc. etc.
--   
--   Note: While I'm unsure whether any n-lang in the Flock core is
--   sufficient to express itself, it's trivial to show that there's an
--   (n+m)-lang that does (because of regularity).
--   
--   Does this preserve: consistency, completeness, decidability,
--   finiteness, haltingness, etc?
--   
--   Well, if it's shown on a nice category-theoretic level, it doesn't
--   really matter, no?
--   
--   <pre>
--   Everything will be preserved, [evil-laugh] XD
--   </pre>
--   
--   (That still cracks me up)
--   
--   Natural extension of <tt>A</tt>. There is a function
--   
--   <pre>
--   f : A -&gt; A',
--   f' :: A' -&gt; A,
--   f' . f = id,
--   A' ~ A <a>=</a> f . f' = id
--   </pre>
--   
--   I wonder if this indeed forms a structure analogous to a factorization
--   system for arbitrary categories?
propertyPreservation :: ()

-- | More possibilities
--   
--   <pre>
--   f :: a -&gt; a',
--   f' :: a' -&gt; a,
--   f' . f = id,
--   Iso (a' ~ a) (f . f' = id)
--   </pre>
twoMoreAttempts :: ()

-- | Summarize and notes:
--   
--   <pre>
--   F, G functors from C to D
--   n, natural transformation F -&gt; G
--     nx :: forall (x :: C). F x -&gt; G x
--     forall (f :: (x :: C) -&gt; (y :: C)).
--       exists (ny :: F y -&gt; G y).
--       ny . F (f :: x -&gt; y) == G (f :: x -&gt; y) . nx
--   </pre>
--   
--   <pre>
--   Functor (f :: * -&gt; *)
--   Functor (g :: * -&gt; *)
--   </pre>
--   
--   <pre>
--   f' = (f / g) * g'
--   f' = (f <i> g) * ((g </i> f) * f')
--   f' = (*) ((<i>) f g) ((*) ((</i>) g f) f')
--   f' = (f <tt>y</tt> g) <tt>x</tt> ((g <tt>y</tt> f) <tt>x</tt> f')
--   f' = x (y f g) (x (y g f) f')
--   
--   g' = (g / f) * f'
--   g' = (g <i> f) * ((f </i> g) * g')
--   g' = (g <tt>y</tt> f) <tt>x</tt> ((f <tt>y</tt> g) <tt>x</tt> g')
--   </pre>
naturalTransformationAlgebra :: ()

-- | Free/Cofree and algebra
--   
--   <pre>
--   newtype Free f a = Free { unfree :: Either a (f (Free f a))) }
--     Either a (f (Free f a))
--     (Either a :.: f :.: Free f)
--   Sum version of Tree f a
--   </pre>
--   
--   <pre>
--   Cofree f a =  a :&lt;  (f (Cofree f a))
--     Tree f a =  a (,) (f (Tree   f a))
--   </pre>
--   
--   <pre>
--   Free f a = Pure a | Free (f (Free f a))
--   Free f a = Either a (f (Free f a))
--   Free f a = Either a (f (Either a (f (Free f a))))
--   Free f a = Either a (f -&gt; (a, (Either a (f -&gt; (a, )(Free f a)))))
--   Free (TT f a b) c = Either a (TT a b (Free (TT f a b) c))
--   Free (TT f a b) c = Either a (TT a b (Either a (TT a b (Free (TT f a b) c))))
--   </pre>
--   
--   <pre>
--   Forest (Either a . f) a = Either a (f (a, Forest f a))
--   Forest f a = f (a, Forest f a)
--   Forest f a = f (Tree f a)
--   </pre>
--   
--   <pre>
--   TT f a b = f a -&gt; (a, b)
--   </pre>
ttDefinition :: ()

-- | Free and Cofree instances:
--   
--   <pre>
--   newtype FreeT   f m a = FreeT   { runFreeT   :: m (FreeF f a (FreeT f m a)) }
--     newtype FreeT   f m a = m (Either a (f (FreeT f m a)))
--     newtype FreeT   f m a = m (Either a (f (m (Either a (f (FreeT f m a))))))
--   data FreeF   f a b = Pure a | Free (f b)
--     data FreeF   f a b = Either a (f b)
--   </pre>
--   
--   <pre>
--   newtype CofreeT f w a = CofreeT { runCofreeT :: w (CofreeF f a (CofreeT f w a)) }
--     newtype CofreeT f w a = w (a, f (CofreeT f w a))
--     newtype CofreeT f w a = w (a, f (w (a, f (CofreeT f w a))))
--   data CofreeF f a b = a :&lt; (f b)
--     data CofreeF f a b = (a, f b)
--   </pre>
--   
--   <pre>
--   Functor f =&gt; Monad (Free f a) =&gt; MonadFree f (Free f) =&gt;
--     wrap :: f (Free f a) -&gt; Free f a
--     wrap x = Pure  (x :: f (Free f a))
--     wrap x = Right (x :: f (Free f a))
--   
--   Monad f =&gt; Monad (Forest f a) =&gt;
--     wrap :: f (Forest f a) -&gt; Forest f a
--     wrap = (coerce :: (f (f (a, Forest f a)) -&gt; f (a, Forest f a)) -&gt; f (Forest f a) -&gt; Forest f a) (join :: Monad f =&gt; f (f (a, Forest f a)) -&gt; f (a, Forest f a))
--   </pre>
freeAndCofree :: ()

-- | A Generalized tree type
--   
--   Question: does any property such that
--   
--   <pre>
--   Prop :: * -&gt; Constraint
--     Prop a
--       =&gt; Prop (Tree Identity a)?
--     Prop a, Prop a + Prop b =&gt; Prop (a, b), Prop a =&gt; Prop (m a)
--       =&gt; Prop (Tree m a)?
--     Prop a =&gt; Prop (m a)
--       =&gt; Prop (Tree m a)?
--   Prop :: (* -&gt; *) -&gt; Constraint
--     Prop Identity, Prop a + Prop b =&gt; Prop (a :*: b), Prop m
--       =&gt; Prop (Tree m)?
--     Prop m
--       =&gt; Prop (Forest m)?
--   Prop :: (* -&gt; * -&gt; *) -&gt; Constraint
--     Prop (,), Prop t
--       =&gt; Prop (ATree t m)?
--     Prop t
--       =&gt; Prop (AForest t m)?
--   </pre>
--   
--   E.g.
--   
--   <pre>
--   instance Alternative m =&gt; Alternative (Forest m)@
--   </pre>
--   
--   But no instance for <tt><a>Tree</a> m</tt>
--   
--   E.g.
--   
--   <pre>
--   instance Functor m =&gt; Comonad (Tree m)
--   </pre>
--   
--   But no instance for <tt><a>Forest</a> m</tt>
newtype Tree m a
Tree :: (a, Forest m a) -> Tree m a
[getTree] :: Tree m a -> (a, Forest m a)

-- | The counterpart to <a>Tree</a>
newtype Forest m a
Forest :: m (Tree m a) -> Forest m a
[getForest] :: Forest m a -> m (Tree m a)

-- | <a>Tree</a> is not a monad transformer, but <tt><a>Tree</a> . m</tt>
--   is, for <tt><a>Monad</a> m</tt>
liftTree :: Monad m => m a -> m (Tree m a)

-- | Push a monadic context into a <a>Forest</a> by binding it and
--   unwrapping the forest.
--   
--   It should be equivalent to:
--   
--   <pre>
--   Forest . join . fmap getForest
--   Forest .        (&gt;&gt;= getForest)
--   </pre>

-- | Note that <a>Tree</a> can only be <a>Alternative</a> with constraints
--   on <tt>a</tt>, so it can't be <a>Alternative</a> in Haskell

-- | Lift an <a>Enum</a> to a <a>Tree</a> type where the outermost is
--   first?
--   
--   Hmm.. I know that we can't use the internal monadic structure of
--   <a>Tree</a> since we know nothing about it.
--   
--   What would we like to do with this? well, it might be nice to add
--   labeling to a <a>Tree</a> using <a>Enum</a>
--   
--   <pre>
--   instance Enum a =&gt; Enum (Tree m a) where
--   
--   -- The functions below are for <a>Forest</a>, since we probably can't do <a>fromEnum</a>
--   
--   -- | the successor of a value. For numeric types, succ adds 1.
--   succM :: a -&gt; a
--   
--   -- | the predecessor of a value. For numeric types, pred subtracts 1.
--   predM :: a -&gt; a
--   
--   -- | Convert from an Int.
--   toEnumM :: Int -&gt; a
--   
--   -- | Convert to an Int. It is implementation-dependent what fromEnum returns when applied to a value that is too large to fit in an Int.
--   fromEnumM :: a -&gt; Int
--   
--   -- | Used in Haskell's translation of [n..].
--   enumFromM :: a -&gt; [a]
--   
--   -- | Used in Haskell's translation of [n,n'..].
--   enumFromThenM :: a -&gt; a -&gt; [a]
--   
--   -- | Used in Haskell's translation of [n..m].
--   enumFromToM :: a -&gt; a -&gt; [a]
--   
--   -- | Used in Haskell's translation of [n,n'..m].
--   enumFromThenToM :: a -&gt; a -&gt; a -&gt; [a]
--   </pre>
ideaInstanceEnum :: ()

-- | Pull out a layer of monadic context from a <a>Forest</a>.
--   
--   Not sure, but I think that the only inhabitants of this type can:
--   
--   <ul>
--   <li>return the original</li>
--   <li>do this</li>
--   <li>swap two <a>Tree</a> values</li>
--   <li>some combination of the above</li>
--   </ul>
pullM :: Functor m => Forest m a -> m (Forest m a)

-- | <a>pullM</a> and <a>extract</a>
pullMa :: Functor m => Forest m a -> m a

-- | Unfold a <a>Tree</a> from a seed value
unfoldTree :: Functor m => (b -> (a, m b)) -> b -> Tree m a

-- | Unfold a <a>Forest</a> from a seed value
unfoldForest :: Functor m => (b -> m (a, b)) -> b -> Forest m a
iterateTree :: Applicative m => (a -> m a) -> a -> m (Tree m a)
iterateForest :: Applicative m => (a -> m a) -> a -> Forest m a
instance GHC.Generics.Generic (Control.Monad.Trans.TreeT.Tree m a)
instance GHC.Generics.Generic (Control.Monad.Trans.TreeT.Forest m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.TreeT.Tree m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.TreeT.Forest m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.Monad.Trans.TreeT.Tree m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.Monad.Trans.TreeT.Forest m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.TreeT.Tree m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.TreeT.Forest m)
instance GHC.Base.Functor m => Control.Comonad.Comonad (Control.Monad.Trans.TreeT.Tree m)
instance GHC.Base.Applicative m => Control.Comonad.ComonadApply (Control.Monad.Trans.TreeT.Tree m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Trans.TreeT.Forest
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.TreeT.Forest m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.TreeT.Forest m)
instance Control.Comonad.Trans.Class.ComonadTrans Control.Monad.Trans.TreeT.Tree
instance Control.Comonad.Trans.Class.ComonadTrans Control.Monad.Trans.TreeT.Forest
instance Data.Functor.Classes.Eq1 t => Data.Functor.Classes.Eq1 (Control.Monad.Trans.TreeT.Tree t)
instance Data.Functor.Classes.Eq1 t => Data.Functor.Classes.Eq1 (Control.Monad.Trans.TreeT.Forest t)
instance Data.Functor.Classes.Ord1 t => Data.Functor.Classes.Ord1 (Control.Monad.Trans.TreeT.Tree t)
instance Data.Functor.Classes.Ord1 t => Data.Functor.Classes.Ord1 (Control.Monad.Trans.TreeT.Forest t)
instance GHC.Base.Monad m => Control.Monad.Free.Class.MonadFree m (Control.Monad.Trans.TreeT.Forest m)
instance (GHC.Base.Monoid a, GHC.Base.Applicative m) => GHC.Base.Monoid (Control.Monad.Trans.TreeT.Tree m a)
instance (GHC.Base.Monoid a, GHC.Base.Applicative m) => GHC.Base.Monoid (Control.Monad.Trans.TreeT.Forest m a)
instance (GHC.Base.Monoid a, GHC.Base.Applicative m) => Data.Semigroup.Semigroup (Control.Monad.Trans.TreeT.Tree m a)
instance (GHC.Base.Monoid a, GHC.Base.Applicative m) => Data.Semigroup.Semigroup (Control.Monad.Trans.TreeT.Forest m a)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Control.Monad.Trans.TreeT.Forest m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.TreeT.Forest m)
instance Control.Monad.Primitive.PrimBase m => Control.Monad.Primitive.PrimBase (Control.Monad.Trans.TreeT.Forest m)
instance Data.Foldable.Foldable m => Data.Foldable.Foldable (Control.Monad.Trans.TreeT.Tree m)
instance Data.Foldable.Foldable m => Data.Foldable.Foldable (Control.Monad.Trans.TreeT.Forest m)
instance Data.Traversable.Traversable m => Data.Traversable.Traversable (Control.Monad.Trans.TreeT.Tree m)
instance Data.Traversable.Traversable m => Data.Traversable.Traversable (Control.Monad.Trans.TreeT.Forest m)
instance (GHC.Base.Applicative m, GHC.Num.Num a) => GHC.Num.Num (Control.Monad.Trans.TreeT.Tree m a)
instance (GHC.Base.Applicative m, GHC.Num.Num a) => GHC.Num.Num (Control.Monad.Trans.TreeT.Forest m a)
instance (GHC.Base.Applicative m, GHC.Real.Fractional a) => GHC.Real.Fractional (Control.Monad.Trans.TreeT.Tree m a)
instance (GHC.Base.Applicative m, GHC.Real.Fractional a) => GHC.Real.Fractional (Control.Monad.Trans.TreeT.Forest m a)
instance (GHC.Base.Applicative m, GHC.Float.Floating a) => GHC.Float.Floating (Control.Monad.Trans.TreeT.Tree m a)
instance (GHC.Base.Applicative m, GHC.Float.Floating a) => GHC.Float.Floating (Control.Monad.Trans.TreeT.Forest m a)

module Control.Arrow.Tree

-- | Like <a>Tree</a>, but the arguments are applied differently, to allow
--   it to be an <a>Arrow</a>
newtype ATree t a b
ATree :: Tree (t a) b -> ATree t a b
[getATree] :: ATree t a b -> Tree (t a) b

-- | See <a>AForest</a>
newtype AForest t a b
AForest :: Forest (t a) b -> AForest t a b
[getAForest] :: AForest t a b -> Forest (t a) b

-- | @<a>o</a> = <a>laog'</a>

-- | Compose two <a>Tree</a>s
comp :: Tree ((->) b) c -> Tree ((->) a) b -> Tree ((->) a) c

-- | <a>coerce</a>
getTree2 :: (Tree ma a -> Tree mb b -> Tree mc c) -> (a, Forest ma a) -> (b, Forest mb b) -> (c, Forest mc c)

-- | <a>unsafeCoerce</a> is used for now, since the following error
--   appears:
--   
--   <pre>
--   • Couldn't match representation of type ‘t a (c, Forest (t a) c)’
--                              with that of ‘t a (Tree (t a) c)’
--       arising from a use of ‘coerce’
--     NB: We cannot know what roles the parameters to ‘t a’ have;
--       we must assume that the role is nominal
--   </pre>
--   
--   This is safe by the following:
--   
--   <pre>
--   (arr coerce .)   :: (Arrow t, Coercible b c) =&gt; t a b -&gt; t a c -- initial definition
--     = (coerce .)   :: (Arrow t, Coercible b c) =&gt; t a b -&gt; t a c -- arr id = id
--     = coerce       :: (Arrow t, Coercible b c) =&gt; t a b -&gt; t a c -- (id .) = id
--   </pre>
arrCoerce :: (Arrow a, Coercible c d) => a b c -> a b d

-- | <a>coerce</a> more strangely doesn't work here either. weird
goal' :: Arrow t => ATree t b c -> ATree t a b -> ATree t a c

-- | Goal function
goal :: Arrow t => Tree (t b) c -> Tree (t a) b -> Tree (t a) c

-- | <a>coerce</a>
trans1 :: ((a, Forest ma a) -> (b, Forest mb b) -> (c, Forest mc c)) -> Tree ma a -> Tree mb b -> Tree mc c

-- | <pre>
--   <a>trans2</a> <a>goal2</a>
--   </pre>
goal1 :: Arrow t => (c, Forest (t b) c) -> (b, Forest (t a) b) -> (c, Forest (t a) c)

-- | <a>coerce</a>
trans2 :: Arrow t => ((c, t b (Tree (t b) c)) -> (b, t a (Tree (t a) b)) -> (c, t a (Tree (t a) c))) -> (c, Forest (t b) c) -> (b, Forest (t a) b) -> (c, Forest (t a) c)

-- | Second goal function
--   
--   <pre>
--   goal2 (x, fx) (y, fy) = (x, arr (uncurry goal) . (fx . arr (const y) &amp;&amp;&amp; fy))
--   </pre>
goal2 :: Arrow t => (c, t b (Tree (t b) c)) -> (b, t a (Tree (t a) b)) -> (c, t a (Tree (t a) c))

-- | Coerce doesn't work here, which is too bad
laog' :: Arrow t => AForest t b c -> AForest t a b -> AForest t a c

-- | <pre>
--   <a>snart1</a> <a>laog1</a>
--   </pre>
laog :: Arrow t => Forest (t b) c -> Forest (t a) b -> Forest (t a) c

-- | <a>coerce</a>
snart1 :: Arrow t => (t b (Tree (t b) c) -> t a (Tree (t a) b) -> t a (Tree (t a) c)) -> Forest (t b) c -> Forest (t a) b -> Forest (t a) c

-- | <pre>
--   <a>snart2</a> <a>laog2</a>
--   </pre>
laog1 :: Arrow t => t b (Tree (t b) c) -> t a (Tree (t a) b) -> t a (Tree (t a) c)

-- | By the logic of <a>arrCoerce</a>, this use of <a>unsafeCoerce</a> is
--   safe
snart2 :: Arrow t => (t b (c, Forest (t b) c) -> t a (b, Forest (t a) b) -> t a (c, Forest (t a) c)) -> t b (Tree (t b) c) -> t a (Tree (t a) b) -> t a (Tree (t a) c)

-- | Opposite of <a>goal2</a>
laog2 :: Arrow t => t b (c, Forest (t b) c) -> t a (b, Forest (t a) b) -> t a (c, Forest (t a) c)

-- | Wow, coerce doesn't work here. I had to use the <a>AForest</a>
--   constructor instead
--   
--   Notes:
--   
--   So, technically, it appears that <a>Tree</a> is only a category when
--   we have a left-identity for <tt>`Arrow a`</tt>
--   
--   We can however do stuff like:
--   
--   <pre>
--   a -&gt; Tree (t a) a
--   t a (Tree (t a) a
--   </pre>
--   
--   <pre>
--   idTree :: Arrow t =&gt; Tree (t a) a
--   idTree1 :: Arrow t =&gt; (a, Forest (t a) a)
--   </pre>
idForest' :: Arrow t => AForest t a a

-- | See <a>idForest</a>
idForest :: Arrow t => Forest (t a) a

-- | <a>coerce</a>
transIdForest1 :: Arrow t => t a (Tree (t a) a) -> Forest (t a) a

-- | <pre>
--   <a>transIdForest2</a> <a>idForest2</a>
--   </pre>
idForest1 :: Arrow t => t a (Tree (t a) a)

-- | <a>arrCoerce</a>
transIdForest2 :: Arrow t => t a (a, Forest (t a) a) -> t a (Tree (t a) a)

-- | Coerced all the way up to <a>idForest</a>
idForest2 :: Arrow t => t a (a, Forest (t a) a)

-- | <a>undefined</a>
forestInv :: (Arrow t, Groupoid t) => AForest t a b -> AForest t b a

-- | <a>undefined</a>
forestInv1 :: (Arrow t, Groupoid t) => Forest (t a) b -> Forest (t b) a

-- | <a>undefined</a>
forestInv2 :: (Arrow t, Groupoid t) => t a (Tree (t a) b) -> t b (Tree (t b) a)

-- | <a>undefined</a>
swaps :: Arrow t => t a (Tree (t a) b) -> t (Tree (t b) a) b

-- | <a>undefined</a>
swaps1 :: Arrow t => t a (b, Forest (t a) b) -> t (a, Forest (t b) a) b

-- | <a>undefined</a>. Ok, I'm convinced that this needs Groupoid
swaps2 :: Arrow t => t a (b, t a (Tree (t a) b)) -> t (a, t b (Tree (t b) a)) b

-- | <pre>
--   <a>inv</a> = <a>forestInv</a>
--   </pre>

-- | <tt>`(.)` = <a>laog'</a></tt>, <tt><a>id</a> = <a>idForest'</a></tt>

-- | <pre>
--   <a>o</a> = <a>goal'</a>
--   </pre>

-- | This also looks a lot like distribution.. (<a>undefined</a>)

-- | Notes on Data.Bifoldable, Data.Bitraversable, etc:
--   
--   <pre>
--   Data.Bifoldable
--   instance Bifoldable t =&gt; Bifoldable (ATree t) where
--     bifoldr :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; t a b -&gt; c
--     bifoldr :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; ATree t a b -&gt; c
--     bifoldr :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; Tree (t a) b -&gt; c
--   
--   This makes me think that Forest (t a) b ~ Forest (Forest t a) b, which would be amazeballs
--   Maybe something similar, like the <tt>wanted</tt> functions?
--   
--   instance Bifoldable t =&gt; Bifoldable (AForest t) where
--     bifoldr :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; t a b -&gt; c
--     bifoldr :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; Forest (t a) b -&gt; c
--   </pre>
--   
--   <pre>
--   Data.Bitraversable
--   class (Bifunctor t, Bifoldable t) =&gt; Bitraversable t
--     bitraverse :: Applicative f =&gt; (a -&gt; f c) -&gt; (b -&gt; f d) -&gt; t a b -&gt; f (t c d)
--   </pre>
--   
--   <pre>
--   Data.Bifunctor.Functor
--   type (:-&gt;) p q = forall a b. p a b -&gt; q a b
--   
--   class BifunctorFunctor t where
--     bifmap :: (p :-&gt; q) -&gt; t p :-&gt; t q
--   </pre>
bifoldableNotes :: ()

-- | This looks a lot like distribution

-- | This is harder than I thought, might be impossible, probably
--   impossible.
--   
--   Try extending <tt>Choice (ATree t)</tt> to not use <tt>Choice (AForest
--   t)</tt>.
--   
--   (Currently, both are <a>undefined</a>.)

-- | REQUIRES DISTRIBUTION: distribute :: Functor f =&gt; f (g a) -&gt; g
--   (f a), Functor f =&gt; f (Tree m a) -&gt; Tree m (f a)

-- | <a>undefined</a>
wantTo :: AForest t a (ATree t a b) -> AForest t (ATree t a b) b

-- | <a>undefined</a>
wantFrom :: AForest t (ATree t a b) b -> AForest t a (ATree t a b)

-- | Impossible instance, no way to convert <tt>a</tt> to <tt>b</tt>.

-- | Re-associate a tuple
sndIn :: ((a, b), c) -> ((a, c), b)

-- | I'm pretty surprised that this isn't in base
assoc :: ((a, b), c) -> (a, (b, c))

-- | Inverse of <a>assoc</a>
unassoc :: (a, (b, c)) -> ((a, b), c)

-- | Lift functions, inside of a <a>Tree</a>, into <a>Arrow</a>s
--   
--   Scratch notes:
--   
--   <pre>
--   arr :: Arrow a =&gt; (b -&gt; c) -&gt; a b c
--   arr . const :: Arrow a =&gt; c -&gt; a b c
--   
--   arr Tree    :: Arrow a =&gt; a (c, Forest (a b) c) (Tree (a b) c)
--   arr getTree :: Arrow a =&gt; a (Tree (a b) c) (c, Forest (a b) c)
--   
--   arr Forest    :: Arrow a =&gt; a (a b (Tree (a b) c)) (Forest (a b) c)
--   arr getForest :: Arrow a =&gt; a (Forest (a b) c) (a b (Tree (a b) c))
--   </pre>
--   
--   Wow, this just blew my mind. If we have cat be an arrow, then the pair
--   operations that I use above are already given!!
--   
--   <pre>
--   TreeArrow (Tree (f, fs)) . TreeArrow (Tree (g, gs)) = TreeArrow (Tree (f, fs . gs))
--   </pre>
--   
--   <pre>
--   compf :: Forest ((-&gt;) b) c -&gt; Forest ((-&gt;) a) b -&gt; Forest ((-&gt;) a) c
--   compf :: (b -&gt; Tree ((-&gt;) b) c) -&gt; (a -&gt; Tree ((-&gt;) a) b) -&gt; (c -&gt; Tree ((-&gt;) a) c)
--   compf :: (b -&gt; (c, Forest ((-&gt;) b) c)) -&gt; (a -&gt; (b, Forest ((-&gt;) a) b)) -&gt; (c -&gt; (c, Forest ((-&gt;) a) c))
--   </pre>
--   
--   I'm willing to bet that Tree is analogous to True (as it's inhabited)
--   and Forest is analogous to False (as it's not, yet):
--   
--   <pre>
--   Tree &amp;&amp; Tree forms a Tree:   (a &amp; b -&gt; c) -&gt; (Tree m a &amp; Tree m b) -&gt; Tree m c
--   Tree || Forest forms a Tree: (a | b -&gt; c) -&gt; (Tree m a | Forest m b) -&gt; Tree m c
--   Forest || Forest forms a Tree: (a | b -&gt; c) -&gt; (Forest m a | Forest m b) -&gt; Forest m c
--   </pre>
--   
--   Ohhh, can we also lift inside? Duh, as long as m is applicative!
--   
--   <pre>
--   (a | b -&gt; c) -&gt; Tree m (a | b) -&gt; Tree m c
--   </pre>
--   
--   Can we convert a comonad to a monad?
--   
--   <pre>
--   (w a -&gt; a) looks like a monad to me, in fact, it appears to be: Forest (CoKleisi a) b,
--     Cokleisli { runCokleisli :: w a -&gt; b }
--     Instances: .. Monad (Cokleisli w a)
--   </pre>
--   
--   Can we convert a monad to a comonad?
--   
--   <pre>
--   (a, a -&gt; m a) looks like a comonad to me, in fact it appears to be: Tree State a
--   </pre>
treeArr :: Arrow a => Tree ((->) b) c -> Tree (a b) c

-- | <a>Forest</a> counterpart to <a>treeArr</a>
forestArr :: Arrow a => Forest ((->) b) c -> Forest (a b) c
instance GHC.Generics.Generic1 (Control.Arrow.Tree.AForest t a)
instance GHC.Generics.Generic (Control.Arrow.Tree.AForest t a b)
instance GHC.Generics.Generic1 (Control.Arrow.Tree.ATree t a)
instance GHC.Generics.Generic (Control.Arrow.Tree.ATree t a b)
instance Control.Arrow.Arrow t => Data.Semigroupoid.Semigroupoid (Control.Arrow.Tree.AForest t)
instance (Control.Arrow.Arrow t, Data.Groupoid.Groupoid t) => Data.Groupoid.Groupoid (Control.Arrow.Tree.AForest t)
instance Control.Arrow.Arrow t => Control.Category.Category (Control.Arrow.Tree.AForest t)
instance GHC.Base.Functor (t a) => GHC.Base.Functor (Control.Arrow.Tree.AForest t a)
instance Data.Bifunctor.Bifunctor t => Data.Bifunctor.Bifunctor (Control.Arrow.Tree.ATree t)
instance Data.Bifunctor.Bifunctor t => Data.Bifunctor.Bifunctor (Control.Arrow.Tree.AForest t)
instance Data.Biapplicative.Biapplicative t => Data.Biapplicative.Biapplicative (Control.Arrow.Tree.ATree t)
instance Data.Biapplicative.Biapplicative t => Data.Biapplicative.Biapplicative (Control.Arrow.Tree.AForest t)
instance Data.Profunctor.Unsafe.Profunctor t => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Tree.ATree t)
instance Data.Profunctor.Unsafe.Profunctor t => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Tree.AForest t)
instance Data.Profunctor.Strong.Strong t => Data.Profunctor.Strong.Strong (Control.Arrow.Tree.AForest t)
instance Data.Profunctor.Choice.Choice t => Data.Profunctor.Choice.Choice (Control.Arrow.Tree.ATree t)
instance Data.Profunctor.Choice.Choice t => Data.Profunctor.Choice.Choice (Control.Arrow.Tree.AForest t)
instance Data.Profunctor.Closed.Closed t => Data.Profunctor.Closed.Closed (Control.Arrow.Tree.ATree t)
instance Data.Profunctor.Closed.Closed t => Data.Profunctor.Closed.Closed (Control.Arrow.Tree.AForest t)
instance Control.Arrow.Arrow t => Data.Semigroupoid.Semigroupoid (Control.Arrow.Tree.ATree t)
instance GHC.Base.Functor (t a) => GHC.Base.Functor (Control.Arrow.Tree.ATree t a)
instance (Control.Arrow.Arrow t, Data.Groupoid.Groupoid t, (TypeError ...)) => Data.Groupoid.Groupoid (Control.Arrow.Tree.ATree t)

module Data.Bidistributable

-- | Distribute over a <a>Bifunctor</a>
class Bifunctor p => Bidistributable p f

-- | Later called "push" and or "push2"
bidistribute :: Bidistributable p f => f (p a b) -> f (p (f a) (f b))

-- | Equivalent to grouping the <a>Left</a> and <a>Right</a> values
--   together, then sequencing:
--   
--   <pre>
--   Right . fmap (fromRight undefined) :: Functor f =&gt; f (Either a b) -&gt; Either a (f b)
--   Left  . fmap (fromLeft  undefined) :: Functor f =&gt; f (Either a b) -&gt; Either (f a) b
--   </pre>
class Swap p
swap :: Swap p => p a b -> p b a

-- | <tt>Rope</tt> transformer type
newtype RopeT p m a b
RopeT :: p a (m (RopeT p m b a)) -> RopeT p m a b
[$sel:pullRopeT:RopeT] :: RopeT p m a b -> p a (m (RopeT p m b a))

-- | Commonly used variable types:
--   
--   <pre>
--   f :: t -&gt; t
--   g :: t -&gt; t
--   a :: t
--   </pre>
commonVariableTypes :: ()

-- | Let <tt>C</tt> be a category. <tt>F</tt> associates (<tt>X</tt> is an
--   object in <tt>C</tt> and <tt>G(X)</tt> is as well):
--   
--   <pre>
--   a  :: X      =&gt; F(a) :: F(X)
--   f  :: X -&gt; Y =&gt; F(f) :: F(X) -&gt; F(Y)
--   id_X :: X -&gt; X =&gt; F(id_X) = id_F(X) :: F(X) -&gt; F(X)
--   f :: X -&gt; Y, g :: Y -&gt; Z, g . f :: X -&gt; Z =&gt; F (g . f) = F(g) . F(f) :: F(X) -&gt; F(Z)
--   
--                      G associates (X is an object in C and G(X) is as well)
--   a  :: X      =&gt; G(a) :: G(X)
--   f  :: X -&gt; Y =&gt; G(f) :: G(X) -&gt; G(Y)
--   id_X :: X -&gt; X =&gt; G(id_X) = id_G(X) :: G(X) -&gt; G(X)
--   f :: X -&gt; Y, g :: Y -&gt; Z, g . f :: X -&gt; Z =&gt; G (g . f) = G(g) . G(f) :: G(X) -&gt; G(Z)
--   </pre>
functorNotes :: ()

-- | We want: functor isomorphisms between these compositions of F and G:
--   
--   <pre>
--   F(G(A))    -- we have a composition of functors
--   F(F(G(A))) -- we partition the outer functor into pieces such that `unique partition (xs :: f (g a))` is true for our partition (if it exists, of course, that's where graph coloring comes in)
--   F(G(F(A))) -- we push the partition into the inner functor, resulting in the connected (f (g a)) pieces being joined along their partitions.
--   </pre>
--   
--   In other words, it pulls the partition up to F's level while pushing
--   the structure of F down into G. The structure of F is available to G
--   in slices (local by definition of the partition).
--   
--   Note: all of these operations are invertible since we have unique
--   partitions.
--   
--   Additionally, the functors which this works for are local functors and
--   computers _really_ like computational and data locality. Like they
--   simply adore it. Computational locality makes stream and massively
--   parallel processing a breeze (case in point, the line-by-line parser I
--   just wrote)
functorIsomorphismCompositions :: ()

-- | That is, we want three natural transformations that are also
--   isomorphisms between those compositions.
--   
--   <pre>
--   f :: X -&gt; Y =&gt; F(G(f)) :: F(G(X)) -&gt; F(G(Y))
--   
--   X :: C =&gt; eta_1(X) :: F(G(X)) -&gt; F(F(G(X))) :: C -&gt; C
--   X :: C =&gt; eta_2(X) :: F(F(G(X))) -&gt; F(G(F(X))) :: C -&gt; C
--   X :: C =&gt; eta_3(X) :: F(G(F(X))) -&gt; F(G(X)) :: C -&gt; C
--   
--   f :: X -&gt; Y :: C -&gt; C =&gt; eta_1(Y) . F(G(f)) = F(F(G(f))) . eta_1(X) :: F(G(X)) -&gt; F(F(G(Y))) :: C -&gt; C
--   f :: X -&gt; Y :: C -&gt; C =&gt; eta_2(Y) . F(F(G(f))) = F(G(F(f))) . eta_2(X) :: F(F(G(X))) -&gt; F(G(F(Y))) :: C -&gt; C
--   f :: X -&gt; Y :: C -&gt; C =&gt; eta_3(Y) . F(G(F(f))) = F(G(f)) . eta_3(X) :: F(G(F(X))) -&gt; F(G(Y)) :: C -&gt; C
--   </pre>
--   
--   We require these natural transformations to be bijections.
--   
--   <pre>
--   The three base words (those functor compositions) are equivalent
--   Functor composition is associative
--   We have a compositional identity, the identity functor
--   </pre>
naturalIsomorphisms :: ()

-- | We thus have a group with the binary operation (.), identity the
--   category identity, every element is invertible because we have
--   isomorphisms between the compositions.
--   
--   It has the presentation: <tt>f g = f f g = f g f</tt>.
--   
--   Since it is a group, we can form the language of elements equivalent
--   to those three words.
--   
--   This diagram makes it clear:
--   
--   (the lines are equivalence and the . is composition)
--   
--   <pre>
--             (f . g)
--               / 
--              /   
--             /     
--            /       
--           /         
--   f . (f . g) --- (f . g) . f
--   </pre>
--   
--   First of all, we have the word "fg".
--   
--   <pre>
--   Next, we have the word formed by performing the substitution "fg -&gt; fgf", namely "fgf".
--   Next, we have the word formed by performing the substitution "fg -&gt; ffg", namely "ffg".
--   </pre>
--   
--   The substitution rules in full are as follows (with the substring "fg"
--   wrapped in parentheses for emphasis alone):
--   
--   <pre>
--   "(fg)  -&gt; f(fg)"
--   "f(fg) -&gt; (fg)"
--   "(fg)  -&gt; (fg)f"
--   "(fg)f -&gt; (fg)"
--   "f(fg) -&gt; (fg)f"
--   "(fg)f -&gt; f(fg)"
--   ----------------
--     It's a rote exercise to show that any rule of the form "f?(fg)f? -&gt; f?(fg)f?" can be derived.
--   </pre>
--   
--   Since the substring "fg" can never be broken by the available base
--   rules, we simply have the ability to induct on "f?(fg)f? -&gt;
--   f?(fg)f?" to form "f{n}(fg)f{m}" for any n,m.
--   
--   We simply compose the base rule with itself (max n m) times. We then
--   resolve the optionals (?'s) to the number of "f"'s desired on either
--   side of the "(fg)" center.
--   
--   We thus have that this language is exactly the regular language:
--   <tt>"(f*)(fg)(f*)"</tt>
regularLanguage :: ()

-- | One example application is <tt>[], Maybe</tt>, where pushing
--   <tt>([Maybe a] -&gt; [Maybe [a]])</tt> partitions by isJust. This is
--   stream-friendly.
--   
--   Another example is <tt>ListT IO, Threaded</tt>, where
--   <tt>Threaded</tt> is a comonad that evaluates its contents on extract,
--   which we can do purely since we're still inside of <tt>ListT IO</tt>
--   and couldn't do otherwise.
--   
--   Pushing in is some parallel execution strategy, in that case.
--   
--   In other words, we can use this to treat monads as comonads. We just
--   do: <tt>(Monad m =&gt; Turn (Compose m f) m)</tt> and the inner
--   <tt>m</tt> can be treated as a comonad inside the turn.
--   
--   I.e. we have: <tt>Monad m =&gt; m (Comonad m =&gt; ())</tt>
--   
--   This could be well-typed if GHC supported impredicative polymorphism,
--   but it doesn't.
--   
--   How does it work?
--   
--   <pre>
--   Well, inside of <tt>m</tt>, we have extract (m (m a) -&gt; m a), which is just join
--   Also, inside of <tt>m</tt>, we still have return so then we get duplicate (m (m a) -&gt; m (m (m a))), which is return = fmap return
--   </pre>
--   
--   Inside of a comonad, we get a monad. This is the free comonad (/monad)
--   
--   Ahhh, don't forget about orthogonal lists, e.g. a 2d array. this may
--   be able to pass layers in and out
exampleApplications :: ()

-- | Really, we want two applications of push to be equivalent to pure push
--   (we don't gain anything from pushing more) (the benefit is that it's
--   equivalent to the limit of the other pushes OR you can consider it as
--   a guarantee that everything to be pushed is pushed in the first push)
--   
--   This is: "pushes are effectively idempotent" (using some "generic"
--   injection into <tt>f</tt> to show that additional pushes do no more
--   than the generic injection)
--   
--   <pre>
--   push  :: forall (a :: c). f (g a) -&gt; f (g (f a))
--   puref :: forall (a :: c). a -&gt; f a
--   
--   push      . push :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))
--   fmap (fmap puref) . push :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))
--   push . push == fmap (fmap puref) . push
--   </pre>
--   
--   This is: "pushes are effectively idempotent" (using some "generic"
--   extraction from <tt>f</tt> (which arguably, we can guarantee in some
--   way when we want all of the strcuture of f that can be pushed to be))
--   
--   <pre>
--   push     :: forall (a :: c). f (g a) -&gt; f (g (f a))
--   extractf :: forall (a :: c). f a -&gt; a
--   
--   push . push                :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))
--   fmap (fmap extractf) . push . push :: f (g a) -&gt; f (g (f a))
--   
--   fmap (fmap extractf) . push . push == push
--   </pre>
--   
--   This is: "pushes are effectively idempotent" (using some "generic"
--   joining of <tt>f</tt>s)
--   
--   <pre>
--   push  :: forall (a :: c). f (g a) -&gt; f (g (f a))
--   joinf :: forall (a :: c). f (f a) -&gt; f a
--   
--   push . push                :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))
--   fmap (fmap joinf) . push . push :: f (g a) -&gt; f (g (f a))
--   
--   fmap (fmap joinf) . push . push == push
--   </pre>
--   
--   This is: "pushes are effectively idempotent" (using some "generic"
--   duplication of <tt>f</tt>'s)
--   
--   <pre>
--   push       :: forall (a :: c). f (g a) -&gt; f (g (f a))
--   duplicatef :: forall (a :: c). f a -&gt; f (f a)
--   
--   push . push                :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))
--   fmap (fmap duplicatef) . push      :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))
--   
--   fmap (fmap duplicatef) . push == push . push
--   </pre>
effectiveIdempotencePush :: ()

-- | I believe that the weakest version is a duplicate that is injective?
--   
--   Hmm, suppose we are within a context. This context is composable with
--   itself.
--   
--   <ul>
--   <li>We want any <a>-</a> 1, which is equivalent to having 2 <a>-</a>
--   1.</li>
--   <li>We want this to be a natural transformation.</li>
--   <li>Ahh, what if we had: f (f a) -&gt; Maybe (f a)</li>
--   <li>Then, we could define the other mappings to match it so that it's
--   always Just.</li>
--   </ul>
--   
--   Regardless, we want to be able to show that the additional
--   compositions provided by pushes are trivial.
weakestVersionDuplicate :: ()

-- | Really, we probably want to have this property on the left as well,
--   namely: partitioning an already partitioned functor only adds a
--   trivial layer, since the functor has already been partitioned.
--   
--   <pre>
--   partition :: f (g a)  -&gt; f (f (g a))
--   fmap partition . partition = fmap puref . partition
--   fmap extract . fmap partition . partition = partition
--   </pre>
leftPartitionProperty :: ()
leastActionExhaustivity :: ()
leastLeftAction :: ()

-- | Question: can we linearize this?
--   
--   Yes, we just map words of functions of type <tt>f (g a) -&gt; f (f (g
--   a))</tt> using the following patterns:
--   
--   <pre>
--   f0
--   fmap f0 . f1
--   fmap (fmap f0) . fmap f1 . f2
--   </pre>
--   
--   Quality preserves the lengths of words, because the words have unique
--   types.
--   
--   We want that (<tt>p=partition</tt>):
--   
--   <pre>
--   "pp" -&gt; "_p"
--   </pre>
--   
--   Now, what is this blank? Hmm.
--   
--   <pre>
--   eta(x) :: f (g (f x)) -&gt; f (g (f (f x)))
--   fn :: x -&gt; y =&gt; eta(y) . f (g (f x)) == f (g (f (f x))) . eta(x)
--   
--   eta^(-1)(x) . eta(y) . f (g (f x)) == f (g (f (f x)))
--   eta^(-1)(x) . eta(y) . f (g x) == f (f (g x))
--   </pre>
--   
--   We want the "real" one to stay fixed on the leftmost of the
--   compositions of <tt>f</tt>s.
linearizationQuestion :: ()
goingTheOtherWayLeastActions :: ()

-- | Suppose we have some natural transformation: <tt>f . g -&gt; f .
--   h</tt>. Is this equivalent to some natural transformation: <tt>g -&gt;
--   h</tt>, up to bijection?
--   
--   One way, take <tt>f</tt>'s identity natural transformation <tt>id_f ::
--   f -&gt; f</tt>. Then the left composition with <tt>(g -&gt; h)</tt> is
--   another natural transformation: <tt>(f . g -&gt; f . h)</tt>, and
--   since <tt>id_f</tt> is a bijection this is as well. Q.E.D.
--   
--   Another way, we have some natural transformation from <tt>(f . g -&gt;
--   f . h)</tt>.
--   
--   <pre>
--   eta is a natural transformation from (f . g) to (f . h).
--   X :: C =&gt; eta_X :: (f . g) x -&gt; (f . h) x
--   X :: C =&gt; beta_X :: g x -&gt; h x
--   eta_Y . (f . g) fn = (f . h) fn . eta_X
--     fn :: X -&gt; Y
--   
--   eta_(beta_Y) . (f . g) fn = (f . h) fn . eta_(beta_X)
--   
--   eta_X :: f x -&gt; f x
--   beta_X :: g x -&gt; h x
--   </pre>
--   
--   Well, this suggests that we can only go the other way when we have a
--   bijection from <tt>(f . g)</tt> to <tt>(f . h)</tt>
--   
--   Otherwise, we wouldn't be able to form bijections between <tt>(eta_X
--   :: (f . g) x -&gt; (f . h) x)</tt> and <tt>(beta_X :: g x -&gt; h
--   x)</tt>.
--   
--   <pre>
--   eta . f . beta . f' == (id :: (f . h) x -&gt; (f . h) x) =&gt; f :: h x -&gt; (f . g) x, f' :: (f . h) x -&gt; g x
--   beta . g . eta . g' == (id :: h x -&gt; h x) =&gt; g :: (f . h) x -&gt; g x, g' :: h x -&gt; (f . g) x
--   </pre>
--   
--   <pre>
--   g == f . g
--   g == f . h
--   h == f . g
--   h == f . h
--   g == h
--   
--   f == f . g
--   </pre>
--   
--   <pre>
--   (g) must be a left identity of (f) under composition
--   </pre>
--   
--   Results:
--   
--   <pre>
--   An injective mapping from a natural transformation :: (g -&gt; h) to one :: (f . g -&gt; f . h) is trivial.
--   An injective mapping from a natural transformation :: (f . g -&gt; f . h) to one :: (g -&gt; h) exists iff (g == h) and (f == f . g), i.e. (g) must be a left identity of (f) under composition.
--   </pre>
naturalTransformationUpToBijection :: ()

-- | Question, is the limit of some functor inhabited? e.g.
--   
--   <pre>
--   The limit of Maybe is inhabited by:
--     Nothing
--     Just Nothing
--     Just (Just Nothing)
--     (the natural numbers)
--   The limit of (x -&gt; (a, x)) has exactly one inhabitant:
--     (a, (a, (a, (a, ..))))
--     (a right-infinite list)
--   The limit of (x -&gt; Either a x) has the inhabitants:
--     Left a
--     Right (Left a)
--     Right (Right (Left a)
--     (the pair (Nat, a))
--   </pre>
--   
--   what about expressing the limit of pushes? That's probably something
--   like:
--   
--   <pre>
--   f (g a) -&gt; f (g (Fix f a))
--   no... hmmm
--   </pre>
functorLimitNotes :: ()

-- | Some notes on composing sequences of functors
--   
--   <pre>
--   f . g == f . g . f
--   f . g == (f . g) . f == ((f . g) . f) . f == (((f . g) . f) . f) . f
--   f . g == f . (f . g) == f . (f . (f . g)) == f . (f . (f . (f . g)))
--   </pre>
--   
--   <pre>
--   a; a,b; a,b,a; a,b,a,b
--   b; b,a; b,a,b; b,a,b,a
--   </pre>
functorCompositionNotes :: ()
instance (Data.Bifunctor.Bifunctor p, GHC.Base.Functor m) => Data.Bifunctor.Bifunctor (Data.Bidistributable.RopeT p m)
instance (Data.Bifunctor.Bifunctor p, GHC.Base.Functor m) => GHC.Base.Functor (Data.Bidistributable.RopeT p m a)
instance (Data.Biapplicative.Biapplicative p, GHC.Base.Applicative m) => Data.Biapplicative.Biapplicative (Data.Bidistributable.RopeT p m)
instance (Data.Biapplicative.Biapplicative p, GHC.Base.Applicative m, GHC.Base.Monoid a) => GHC.Base.Applicative (Data.Bidistributable.RopeT p m a)
instance Data.Bidistributable.Swap (,)
instance Data.Bidistributable.Swap Data.Either.Either
instance Data.Bidistributable.Bidistributable Data.Either.Either []

module Data.Flip

-- | A four-part mutually recursive data type
--   
--   Notes:
--   
--   Number of cycles: w.l.o.g we require the first element to be the
--   minimum
--   
--   <pre>
--   1 minimum
--   * permutations of all else
--   (n-1)! ?
--   </pre>
--   
--   E.g. for two, there's exactly one cycle:
--   
--   <pre>
--   Value, Container =&gt;
--     Value * Container (..), Container (Value * ..)
--     Value + Container (..), Container (Value + ..)
--   </pre>
--   
--   Interesting example: unary / binary
--   
--   <pre>
--   (a -&gt; b)
--   (a -&gt; b -&gt; c)
--   
--   a -&gt; b
--   a -&gt; (b -&gt; c)
--   a -&gt; (a, b, b -&gt; c)
--   b -&gt; (b, c)
--   a -&gt; (b, (b -&gt; (c, next)))
--   </pre>
--   
--   Want:
--   
--   Applicative instances for <a>F1</a>, <a>F3</a>
--   
--   <a>Comonad</a> instances for <a>F2</a>, <a>F4</a>
newtype F1 a b c
F1 :: (a -> F2 a b c) -> F1 a b c
[getF1] :: F1 a b c -> a -> F2 a b c

-- | Continuation of <a>F1</a>
newtype F2 a b c
F2 :: (b, F3 a b c) -> F2 a b c
[getF2] :: F2 a b c -> (b, F3 a b c)

-- | Continuation of <a>F2</a>
newtype F3 a b c
F3 :: (b -> F4 a b c) -> F3 a b c
[getF3] :: F3 a b c -> b -> F4 a b c

-- | Continuation of <a>F3</a>
newtype F4 a b c
F4 :: (c, F1 a b c) -> F4 a b c
[getF4] :: F4 a b c -> (c, F1 a b c)

-- | I believe the exact list of "free" morphisms between <tt>F</tt>'s is:
--   
--   <pre>
--   1 -&gt; 1          (we don't have an <tt>a</tt>, and F1's the only one that depends directly on <tt>a</tt>)
--   2 -&gt; 1, 2, 3, 4 (see implementations)
--   3 -&gt; 3          (as with F1, we don't have <tt>b</tt>..)
--   4 -&gt; 1, 4       (<a>snd</a> gives F1, then we get stuck)
--   </pre>
freeMorphismsNotes :: ()

-- | <a>id</a>
morphF11 :: F1 a b c -> F1 a b c
functorMorphF11 :: TestBatch

-- | <a>F2</a> to <a>F4</a>, then <a>F4</a> to <a>F1</a>
morphF21 :: F2 a b c -> F1 a b c
functorMorphF21 :: TestBatch

-- | <a>id</a>
morphF22 :: F2 a b c -> F2 a b c
functorMorphF22 :: TestBatch

-- | Get and <a>snd</a>
morphF23 :: F2 a b c -> F3 a b c
functorMorphF23 :: TestBatch

-- | Get and apply the <tt>b</tt> in <a>F2</a> to the function in <a>F3</a>
morphF24 :: F2 a b c -> F4 a b c
functorMorphF24 :: TestBatch

-- | <a>id</a>
morphF33 :: F3 a b c -> F3 a b c
functorMorphF33 :: TestBatch

-- | Get and <a>snd</a>
morphF41 :: F4 a b c -> F1 a b c
functorMorphF41 :: TestBatch

-- | <a>id</a>
morphF44 :: F4 a b c -> F4 a b c
functorMorphF44 :: TestBatch
testF1Functor :: TestBatch
testF2Functor :: TestBatch
testF3Functor :: TestBatch
testF4Functor :: TestBatch

-- | Stub instance

-- | Stub instance

-- | Note that of <a>F1</a>, <a>F2</a>, <a>F3</a>, and <a>F4</a>, only
--   <a>F4</a> is always a <a>Comonad</a> (if <tt>a ~ b ~ c</tt>, for
--   example, I believe <a>F2</a> would be one as well):
--   
--   <a>F1</a> would need <a>F2</a> to be a <a>Comonad</a>, and a default
--   value for <tt>a</tt>
--   
--   <a>F2</a> would require <a>F3</a> to be a <a>Comonad</a>
--   
--   <a>F3</a> would require a default value for <tt>b</tt>, and for
--   <a>F4</a> to be a <a>Comonad</a> (which I believe it is)
--   
--   <pre>
--   extend extract = ext
--     ext (F4 ~(x, xs)) = F4 (x, F1 . fmap (F2 . fmap (F3 . fmap ext . getF3) . getF2) . getF1 $ xs)
--   
--     since F1, F2, F3, getF1, getF2, getF3, fmap do not affect the values, aside from <tt>fmap ext</tt>, I believe this may be proof of: ext == id
--   
--   extend extract      = id
--   extract . extend f  = f
--   extend f . extend g = extend (f . extend g)
--   </pre>

-- | Like <a>flip</a>
newtype Flip f a b
Flip :: f b a -> Flip f a b
[getFlip] :: Flip f a b -> f b a

-- | <a>coerce</a>
withFlip :: (Flip f1 a1 b1 -> Flip f a b) -> f1 b1 a1 -> f b a

-- | <a>Flip</a> for three arguments
newtype Flip2 f a b c
Flip2 :: f c b a -> Flip2 f a b c
[getFlip2] :: Flip2 f a b c -> f c b a

-- | Coerce
withFlip2 :: (Flip2 f1 a1 b1 c1 -> Flip2 f a b c) -> f1 c1 b1 a1 -> f c b a

-- | A newtype to ensure generated functions (<a>Arbitrary</a>) are
--   inverses of each other
newtype SomeIso a b
SomeIso :: (b -> a, a -> b) -> SomeIso a b
[getSomeIso] :: SomeIso a b -> (b -> a, a -> b)

-- | Ignore arguments

-- | Unsigned integer addition is an inverse to subtraction

-- | Test <a>IsoFunctor</a>
testIsoFunctor :: (IsoFunctor f, EqProp (f a), Show (f a), Arbitrary (SomeIso a a), Arbitrary (f a)) => f a -> TestBatch

-- | A "functor" that requires an isomorphism to map over
class IsoFunctor f
isomap :: IsoFunctor f => (b -> a) -> (a -> b) -> f a -> f b

-- | Uses <a>Word</a>, <a>testIsoFunctor</a>
testIsoFunctorF1 :: TestBatch

-- | Uses <a>Word</a>, <a>testIsoFunctor</a>
testIsoFunctorF2 :: TestBatch

-- | Uses <a>Word</a>, <a>testIsoFunctor</a>
testIsoFunctorF3 :: TestBatch

-- | Uses <a>Word</a>, <a>testIsoFunctor</a>
testIsoFunctorF4 :: TestBatch

-- | All <a>TestBatch</a>s
testBatches :: [TestBatch]

-- | Run all test batches using <a>quickBatch</a>
quickTestBatches :: IO ()
instance GHC.Show.Show (f c b a) => GHC.Show.Show (Data.Flip.Flip2 f a b c)
instance GHC.Classes.Ord (f c b a) => GHC.Classes.Ord (Data.Flip.Flip2 f a b c)
instance GHC.Classes.Eq (f c b a) => GHC.Classes.Eq (Data.Flip.Flip2 f a b c)
instance Test.QuickCheck.Arbitrary.Arbitrary (f b a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.Flip f a b)
instance Test.QuickCheck.Checkers.EqProp (f b a) => Test.QuickCheck.Checkers.EqProp (Data.Flip.Flip f a b)
instance GHC.Show.Show (f b a) => GHC.Show.Show (Data.Flip.Flip f a b)
instance GHC.Classes.Ord (f b a) => GHC.Classes.Ord (Data.Flip.Flip f a b)
instance GHC.Classes.Eq (f b a) => GHC.Classes.Eq (Data.Flip.Flip f a b)
instance GHC.Show.Show b => GHC.Show.Show (Data.Flip.F2 a b c)
instance GHC.Show.Show c => GHC.Show.Show (Data.Flip.F4 a b c)
instance Data.Flip.IsoFunctor (Data.Flip.Flip (Data.Flip.F1 a) c)
instance Data.Flip.IsoFunctor (Data.Flip.Flip (Data.Flip.F2 a) c)
instance Data.Flip.IsoFunctor (Data.Flip.Flip (Data.Flip.F3 a) c)
instance Data.Flip.IsoFunctor (Data.Flip.Flip (Data.Flip.F4 a) c)
instance GHC.Show.Show (Data.Flip.SomeIso a b)
instance Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.SomeIso GHC.Types.Word GHC.Types.Word)
instance Data.Functor.Contravariant.Contravariant (Data.Flip.Flip2 Data.Flip.F1 a b)
instance Data.Functor.Contravariant.Contravariant (Data.Flip.Flip2 Data.Flip.F2 a b)
instance Data.Functor.Contravariant.Contravariant (Data.Flip.Flip2 Data.Flip.F3 a b)
instance Data.Functor.Contravariant.Contravariant (Data.Flip.Flip2 Data.Flip.F4 a b)
instance GHC.Base.Functor (Data.Flip.F1 a b)
instance GHC.Base.Functor (Data.Flip.F2 a b)
instance GHC.Base.Functor (Data.Flip.F3 a b)
instance GHC.Base.Functor (Data.Flip.F4 a b)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Show.Show a, Test.QuickCheck.Arbitrary.Arbitrary b, GHC.Classes.Eq b, GHC.Show.Show b, GHC.Classes.Eq c) => Test.QuickCheck.Checkers.EqProp (Data.Flip.F1 a b c)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Show.Show a, Test.QuickCheck.Arbitrary.Arbitrary b, GHC.Classes.Eq b, GHC.Show.Show b, GHC.Classes.Eq c) => Test.QuickCheck.Checkers.EqProp (Data.Flip.F2 a b c)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Show.Show a, Test.QuickCheck.Arbitrary.Arbitrary b, GHC.Classes.Eq b, GHC.Show.Show b, GHC.Classes.Eq c) => Test.QuickCheck.Checkers.EqProp (Data.Flip.F3 a b c)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Show.Show a, Test.QuickCheck.Arbitrary.Arbitrary b, GHC.Classes.Eq b, GHC.Show.Show b, GHC.Classes.Eq c) => Test.QuickCheck.Checkers.EqProp (Data.Flip.F4 a b c)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.CoArbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.F1 a b c)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.CoArbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.F2 a b c)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.CoArbitrary b, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.F3 a b c)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.CoArbitrary b, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.F4 a b c)
instance GHC.Show.Show (Data.Flip.F1 a b c)
instance GHC.Show.Show (Data.Flip.F3 a b c)
instance Control.Comonad.Comonad (Data.Flip.F4 a b)

module Data.Functor.Object

-- | Both a right result and a continuation (<a>Action</a>)
data Object f b c
Object :: (c, Action f b c) -> Object f b c
[getObject] :: Object f b c -> (c, Action f b c)

-- | An action which could contain a left result, continuation
--   (<a>Object</a>)
data Action f b c
Action :: (f b (Object f b c)) -> Action f b c
[runAction] :: Action f b c -> (f b (Object f b c))

-- | Simple fixed point newtype
newtype Fix f
Fix :: f (Fix f) -> Fix f
[runFix] :: Fix f -> f (Fix f)

-- | Cycle a pair, resulting in a fixed point
cyclePair :: Object (,) a b -> Fix ((,) (a, b))

-- | Convert a <a>Fix</a> to an infinite list
fixList :: Fix ((,) a) -> [a]

-- | <a>Object</a>, but with a sum (<a>Either</a>) instead of a tuple
data Result f b c
Result :: Either c (Effect f b c) -> Result f b c
[getResult] :: Result f b c -> Either c (Effect f b c)

-- | <a>Action</a>, but with a sum (<a>Either</a>) instead of a tuple
data Effect f b c
Effect :: f b (Result f b c) -> Effect f b c
[runEffect] :: Effect f b c -> f b (Result f b c)

-- | Given all the functional pairs to define a function, we can cyclically
--   wrap the pairs into an <a>Action</a> over pairs.
--   
--   Consider generalizing to other nice <tt>(* -&gt; * -&gt; *)</tt>'s
fromAll :: NonEmpty (a, b) -> Action (,) a b

-- | interesting..
ish :: (a -> b -> (a', b')) -> NonEmpty a -> NonEmpty b -> Action (,) a' b'

-- | Effectively define <a>fst</a> for an <a>Action</a> over pairs, using
--   all cases
fstIsh :: NonEmpty a -> NonEmpty b -> Action (,) (a, b) a

-- | Effectively define <a>snd</a> for an <a>Action</a> over pairs, using
--   all cases
sndIsh :: NonEmpty a -> NonEmpty b -> Action (,) (a, b) b

-- | Since there's only a finite number of a's, we can cycle through til we
--   match, then continue on
appIsh :: (Eq a, Functor (f t)) => Action (,) a b -> Object f t a -> Object f t b

-- | Convert a flipped result to an either (sum)
toEither :: Flip (Result (Flip (Object f))) c b -> Either c b

-- | Convert a flipped result to a tuple (product)
toPair :: Flip (Object (Flip (Object f))) c b -> (c, b)

-- | Undo an <a>Action</a>
unAction :: Functor (f b) => Action f b c -> f b c

-- | Undo an <a>Object</a>
unObject :: Functor (f b) => Object f b c -> (f b c, c)

-- | Convert to an <a>Action</a>
toAction :: Functor (f b) => f b c -> Action f b c

-- | Convert to an <a>Object</a>
toObject :: Functor (f b) => f b c -> c -> Object f b c

-- | <a>toAction</a>
fstAction :: Functor (f (b, c)) => f (b, c) b -> Action f (b, c) b

-- | <a>toObject</a>
fstObject :: Functor (f (b, c)) => f (b, c) b -> b -> Object f (b, c) b

-- | <a>toAction</a>
sndAction :: Functor (f (b, c)) => f (b, c) c -> Action f (b, c) c

-- | <a>toObject</a>
sndObject :: Functor (f (b, c)) => f (b, c) c -> c -> Object f (b, c) c

-- | <a>toAction</a>
swapAction :: Functor (f (b, c)) => f (b, c) (c, b) -> Action f (b, c) (c, b)

-- | <a>toObject</a>
swapObject :: Functor (f (b, c)) => f (b, c) (c, b) -> (c, b) -> Object f (b, c) (c, b)

-- | <a>toAction</a>
mapEitherAction :: Functor (f (c -> d, Either b c)) => f (c -> d, Either b c) (Either b d) -> Action f (c -> d, Either b c) (Either b d)

-- | <a>toObject</a>
mapEitherObject :: Functor (f (c -> d, Either b c)) => f (c -> d, Either b c) (Either b d) -> Either b d -> Object f (c -> d, Either b c) (Either b d)
instance GHC.Generics.Generic (Data.Functor.Object.Fix f)
instance GHC.Base.Functor (f b) => GHC.Base.Functor (Data.Functor.Object.Result f b)
instance GHC.Base.Functor (f b) => GHC.Base.Functor (Data.Functor.Object.Effect f b)
instance GHC.Show.Show a => GHC.Show.Show (Data.Functor.Object.Fix ((,) a))
instance GHC.Base.Functor (f b) => GHC.Base.Functor (Data.Functor.Object.Object f b)
instance GHC.Base.Functor (f b) => GHC.Base.Functor (Data.Functor.Object.Action f b)
instance Control.Comonad.Comonad (f b) => Control.Comonad.Comonad (Data.Functor.Object.Object f b)
instance Control.Comonad.Comonad (f b) => Control.Comonad.Comonad (Data.Functor.Object.Action f b)

module Data.Rope

-- | This is a fun data type, later called.. a <a>Chain</a>
newtype Rope p a b
Rope :: p a (Rope p b a) -> Rope p a b
[pullRope] :: Rope p a b -> p a (Rope p b a)

-- | <a>undefined</a>
--   
--   <pre>
--   [Either a b] -&gt; Rope Either [a] [b]
--   </pre>
goalRope :: f (p a b) -> Rope p (f a) (f b)

-- | For:
--   
--   <pre>
--   instance Swap Iso'
--   </pre>
--   
--   But this doesn't seem to work either:
--   
--   <pre>
--   instance Swap NIso where
--     swap = NIso . from . getNIso
--   </pre>
--   
--   newtype NIso a b = NIso { getNIso :: Iso' a b }
--   
--   <a>Twist</a> a binary type operator into a <a>Rope</a>
class Twist f p
twist :: Twist f p => f (p a b) -> Rope p (f a) (f b)
instance GHC.Base.Functor f => Data.Rope.Twist f (,)
instance Control.Comonad.Comonad f => Data.Rope.Twist f Data.Either.Either
instance Data.Functor.Classes.Eq2 p => Data.Functor.Classes.Eq2 (Data.Rope.Rope p)
instance (Data.Functor.Classes.Eq2 p, GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.Rope.Rope p a b)
instance Data.Functor.Classes.Ord2 p => Data.Functor.Classes.Ord2 (Data.Rope.Rope p)
instance (Data.Functor.Classes.Ord2 p, GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Data.Rope.Rope p a b)
instance Data.Functor.Classes.Show2 p => Data.Functor.Classes.Show2 (Data.Rope.Rope p)
instance (Data.Functor.Classes.Show2 p, GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Rope.Rope p a b)
instance Data.Bifunctor.Bifunctor p => Data.Bifunctor.Bifunctor (Data.Rope.Rope p)
instance Data.Bifunctor.Bifunctor p => GHC.Base.Functor (Data.Rope.Rope p a)
instance Data.Biapplicative.Biapplicative p => Data.Biapplicative.Biapplicative (Data.Rope.Rope p)
instance (Data.Biapplicative.Biapplicative p, GHC.Base.Monoid a) => GHC.Base.Applicative (Data.Rope.Rope p a)

module Data.SwapList

-- | <a>expand</a> and <a>contract</a>
--   
--   <pre>
--   dist :: f (p a b) -&gt; RopeT m p (f a) (f b)
--   
--   dist :: f (Either a b) -&gt; RopeT Maybe (,) (f a) (f b)
--   </pre>
class Functor f => Biexpandcontract (q :: * -> * -> *) (p :: * -> * -> *) (f :: * -> *)
expand :: Biexpandcontract q p f => f (p a b) -> q (a) (b)
contract :: Biexpandcontract q p f => q (f a) (f b) -> f (p a b)

-- | An example data type for <a>Biexpandcontract</a>
--   
--   <pre>
--   X a b = X (a, Maybe (Y a b))
--   Y a b = Y (b, Maybe (X a b))
--   
--   Z a b = Either (X a b) (Y a b)
--   
--   W a b = W (a, Maybe (W b a))
--   Z a b = Either (W a b) (W b a)
--   Z a b = let w x y = (x, Maybe (w y x)) in Either (w a b) (w b a)
--   </pre>
--   
--   <pre>
--   [(a, b)]     -&gt; ([a], [b])
--   [Either a b] -&gt; Either (w a b) (flip w a b)
--   f (p a b)    -&gt; p (g a b) (h a b)
--   </pre>
--   
--   <pre>
--   Maybe (Either (NonEmpty a) (NonEmpty b), SwapList a b)
--   </pre>
data SwapList a b
SwapLeft :: a -> [a] -> (SwapList a b) -> SwapList a b
SwapRight :: b -> [b] -> (SwapList a b) -> SwapList a b
SwapEmpty :: SwapList a b

-- | Uses <a>seqComonad</a>

-- | Lazily seqence a <a>Comonad</a>, by recursively <a>tail</a>ing inside
--   the <a>Functor</a>, then using <a>catMaybes</a> and
--   <a>maybeComonad</a> to extract the values.
seqComonad :: Comonad f => f [a] -> [f a]

-- | <a>extract</a> to check whether it's <a>Nothing</a>, else use
--   <tt><a>Just</a> . <a>fmap</a> <a>fromJust</a></tt>
maybeComonad :: Comonad f => f (Maybe a) -> Maybe (f a)

-- | uses <a>leftExpand</a> and <a>rightExpand</a>
--   
--   Notes:
--   
--   <pre>
--   contract :: q [a] [b] -&gt; [Either a b]
--   
--   [[a], [b], [a], [b], [a], [b]]
--   </pre>

-- | Expand a <a>SwapList</a> on the left
leftExpand :: (a, [a]) -> [Either a b] -> SwapList a b

-- | Expand a <a>SwapList</a> on the right
rightExpand :: (b, [b]) -> [Either a b] -> SwapList a b

-- | One way of thinking about this is distributing a partition on the
--   image of a functor <tt>(C -&gt; D)</tt> over the functor to get a new
--   functor from C to the partitions.
--   
--   <pre>
--   Functor f =&gt; (f a -&gt; partition (f a)) -&gt; f (partition a) -&gt; partition (f a)
--   </pre>
--   
--   OR we have a language formed along some scaffolding structure, for
--   example a list, binary tree, etc. We also have a partition of the
--   language on its own. We then want to map an arbitrary expression to a
--   new, unique scaffolding structure, where adjacent language terms
--   within the scaffolding never are within the same equivalence classes
--   within the language.
--   
--   For example, if our partition is <tt>(isLeft)</tt> and our scaffolding
--   structure is a list then the new scaffolding is formed like so:
--   
--   <pre>
--   [Either a b] -&gt; Maybe (Either (Others a b) (Others b a))
--   Others x y = (x, Maybe (Others y x))
--   </pre>
introductionNotes :: ()

-- | Factorization of languages
--   
--   These are effectively factorizations of languages, as we move from a
--   language built on scaffolding to a language of homogenous sublanguages
--   built on two layers of scaffolding:
--   
--   the original layer, that holds up the individual sublanguage of its
--   slice of the partition a layer, at least as constrained (likely
--   smaller), that holds up the original layer
--   
--   That is, this is a factorization of the scaffolding layers along a
--   partition of the base language.
--   
--   If the splitting has nice properties, we may be able to show that
--   there isn't any overlap between the two layers and so we can lift
--   solutions on each to the total using some sort of disjoint (xor) sum.
--   
--   This would allow type-solving to be split up between the languages,
--   allowing study of each language to be immediately lifted to the study
--   of both.
--   
--   Which is exactly what we want: nice liftings between the languages and
--   localized addition/removal of features.
--   
--   One may define a structural fold, for example:
--   
--   <pre>
--   fold (x : ys) = fold_: x ys
--   fold []       = fold_[]
--   
--   data Expr a where
--     App :: Expr a -&gt; Expr a -&gt; Expr a
--     Lit :: a
--   
--   fold (App x y) = fold_App x y
--   fold (Lit x  ) = fold_Lit x
--   </pre>
--   
--   We then define a set of subterms to be adjacent iff there exists some
--   GADT term of the form:
--   
--   <pre>
--   GADTerm :: subterm1 -&gt; subterm2 -&gt; subterm3 -&gt; ... -&gt; Expr
--   </pre>
--   
--   Thus, we have that valid partitions are
--   
--   <pre>
--   let G be the graph formed by mapping adjacent sets to complete subgraphs
--   the partition forms a valid coloring of the resulting graph
--   </pre>
--   
--   Question: Is a partition on an expression valid iff it is a valid
--   coloring of that graph? YES.
--   
--   We thus have: iif the partition forms a valid coloring of every graph
--   formed from an expression by connecting every vertex in a set of
--   adjacent terms (GADT-wise) to every other in the set.
--   
--   The partition can be uniquely distributed into the terms of the
--   language over some scaffolding structure (the language formed by
--   joining adjacent and equal-kinded terms recursively)
--   
--   We might want to define a "regular" or "homogenous" partition, one
--   that partitions according to leaf-GADT terms?
--   
--   <pre>
--   e.g. isLeft partitions over the GADT terms, Left _ -&gt; set1, Right _ -&gt; set2
--   these seem more trivial, then it seems that we can do it iff no GADT-term is adjacent to itself? Mmmm, or adjacent to itself in an ambiguous way?
--   Hmmm.. it seems that we can make it work if we have an unambiguous and correct way to squash/fold adjacent terms..
--   </pre>
factorizationOfLanguages :: ()

-- | What do we have?
--   
--   <pre>
--   We have some functor f from C -&gt; D.
--   We have a binary relation on members of D (f a) that forms an undirected graph called isAdjacent.(?)
--   We have a partition on members of C (a)
--   </pre>
--   
--   With these together, we have that there is a unique way of mapping
--   adjacent members of D with the same partition of C to a single member
--   of `f (f a)`? (Such that we get a new structure where the structure of
--   the adjacent members is pushed out into the "leaves".)
--   
--   <pre>
--   Functor f
--   fmap :: (a -&gt; b) -&gt; f a -&gt; f b
--   (a -&gt; Partition)
--   fmap (a -&gt; Partition) -&gt; f a -&gt; f Partition
--   f a -&gt; g (f a), where
--    part :: a -&gt; Partition
--    unique :: Eq a =&gt; f a -&gt; Maybe a :: if all the elements are equal, return just that element else nothing
--    fmap part :: f a -&gt; f Partition
--    unique . fmap part :: f a -&gt; Maybe a
--    mapM (unique . fmap part) :: g (f a) -&gt; Maybe (g a)
--    isJust (mapM (unique . fmap part)) :: g (f a) -&gt; Bool
--   </pre>
quickRecap :: ()

-- | Hmmm.. we seem to have three parts:
--   
--   <pre>
--   How do we specify the adjacency on the structure?
--   How do we specify the partition on the values?
--   How do we specify that we can join connected collections of adjacent values with the same partition? (join into the structure)
--   </pre>
--   
--   <pre>
--   structure values
--   part :: values -&gt; Partition
--   adjacent :: value in structure -&gt; value in structure -&gt; Bool
--   </pre>
--   
--   Mmmmm, we don't really care what the adjacency relation is, we only
--   care that we have a partition on the structure such that we can group
--   values together along that partition.
--   
--   What do we mean by group together? Well, we'd like a unique and
--   consistent bijection betwwen: <tt>f a <a>-</a> f (f a)</tt> such that
--   all of the <tt>a</tt>'s in any substructure <tt>(f a)</tt> belong to
--   the same partition.
--   
--   A partition is just an injective function. So we want <tt>(f a -&gt;
--   whichPartition)</tt> for the inner layer.
--   
--   <tt>(f a -&gt; whichPartition)</tt> is the <tt>function :: (p :: a
--   -&gt; b) -&gt; (f a | singleton . toSet . fmap p) -&gt; b</tt>
--   
--   Mmmm or really do we want:
--   
--   <pre>
--   f a -&gt; f (g a) -&gt; (g a -&gt; f a) -&gt; f (f a)
--   </pre>
threePartsOfSpecification :: ()

-- | Ok, we have some structure and some structure preserving bijection
--   that pushes as much of the structure inside the object structure?
--   
--   <pre>
--   f (g a) <a>-</a> f (g (f a))
--     T a =&gt; [T a] -&gt; T [a]
--     T a b =&gt; [T a b] -&gt; T [a] [b]
--     T a | U b =&gt; [T a b] -&gt; [T [a] | U [b]]
--     (a -&gt; b) =&gt; [a -&gt; b] -&gt; [a -&gt; [b] | [a] -&gt; b]
--     (a , b)  =&gt; Tree (a, b) -&gt; Tree (Tree a, Tree b)
--     (a | b)  =&gt; Tree (a | b) -&gt; Tree (Tree a | Tree b)
--     (a -&gt; b) =&gt; Tree (a -&gt; b) -&gt; Tree (a -&gt; Tree b | Tree a -&gt; b)
--     a? =&gt; Tree a? -&gt; Tree (Tree a)?
--       a? = a | _|_ = (?) a
--     [a] =&gt; Tree [a] -&gt; Tree (Tree _|_ | Tree a | Tree (a, [x]) | Tree [x, a] | Tree [..])
--     ([a] = (:) a [a] :: [a] | [] :: [a]) =&gt; Tree [a] -&gt; Tree [Tree a]
--   </pre>
structurePreservingBijection :: ()

-- | What are some valid partitions of some datatypes?
--   
--   <pre>
--   f (a) -&gt; (f a)
--   f (a, b) -&gt; (f a, f b) | (a, f b) | (f a, b)
--   
--   f (a1, b1) (a2, b2) &amp;&amp; a1 ~ b1 &amp;&amp; a2 ~ b2 =&gt; (f a1 a2, f b1 b2)
--   f (a1, b1) (a2, b2) &amp;&amp; a1 ~ a2 =&gt; (a1, f b1 b2)
--   f (a1, b1) (a2, b2) &amp;&amp; b1 ~ b2 =&gt; (f a1 a2, b2)
--   
--   f (g a1) (g a2) | a1 ~ a2 =&gt; g (f a1 a2)
--   </pre>
--   
--   <pre>
--   fp :: t -&gt; t -&gt; Maybe t
--   
--   f (g a1 b1) (g a2 b2) | fp a1 a2 &amp;&amp; fp b1 b2 =&gt; g (fp a1 a2 ::   a) (fp b1 b2 ::   b)
--   f (g a1 b1) (g a2 b2) | fp a1 a2             =&gt; g (fp a1 a2 ::   a) (f  b1 b2 :: f b)
--   f (g a1 b1) (g a2 b2) |             fp b1 b2 =&gt; g (f  a1 a2 :: f a) (fp b1 b2 ::   b)
--   f (g a1 b1) (g a2 b2) |                      =&gt; f (f  a1 a2 :: f a) (f  b1 b2 :: f b)
--   </pre>
--   
--   What are we doing here? zipping the following function:
--   
--   <pre>
--   If fp a1 a2 (we can join a1 and a2) then fp a1 a2 else f b1 b2
--   </pre>
--   
--   We must be able to do the following:
--   
--   <pre>
--   (a1 -&gt; a2 -&gt; a3) -&gt; (b1 -&gt; b2 -&gt; b3) -&gt; g a1 b1 -&gt; g a2 b2 -&gt; g a3 b3
--   </pre>
--   
--   We must also be able to tell which of the zippings apply.
--   
--   <pre>
--   (a1 -&gt; a2 -&gt; Either a3 (fa a1 a2)) -&gt; (b1 -&gt; b2 -&gt; Either b3 (fb b1 b2)) -&gt; g a1 b1 -&gt; g a2 b2 -&gt; g a3 b3 | g a3 (fb b1 b2) | g (fa a1 a2) b3 | g (fa a1 a2) (fb b1 b2)
--   c :: fa a -&gt; fb b -&gt; .. -&gt; fz z -&gt; c a b .. z
--   c :: fa a1 -&gt; fa a2 -&gt; c a1 a2
--   Left  :: a -&gt; Either a b
--   Right :: b -&gt; Either a b
--   fa :: a -&gt; a -&gt; f a
--   fb :: b -&gt; b -&gt; f b
--   f :: forall t. t -&gt; t -&gt; f t
--   _ :: (a -&gt; a -&gt; Either a (f a)) -&gt; (b -&gt; b -&gt; Either b (f b)) -&gt; Either a b -&gt; Either a b -&gt; Either a b | Either a (f b) | Either (f a) b | f (Either a b)
--   _ g h (F (Left  x) (Left  y)) = Left  (g x y)
--   _ g h (F (Right x) (Right y)) = Right (h x y)
--   _ g h (F        x         y ) = F x y
--   (a1 -&gt; a2 -&gt; Either a3 (c fa a1 -&gt; fa a2 -&gt;
--   </pre>
someValidPartitions :: ()

-- | Misc. notes:
--   
--   <pre>
--   [(1, 2), (1, 2)] =&gt; ([1, 1], [2, 2])
--   [(1, 2), (1, 3)] =&gt; (1, [2, 3])
--   [(1, 3), (2, 3)] =&gt; ([1, 2], 3)
--   [(1, 2), (3, 4)] =&gt; ([1, 3], [2, 4])
--   </pre>
--   
--   <pre>
--   f (a | b) -&gt; f a | f b
--   f (a | (a, b)) -&gt; f a | (f a, f b) | (a, f b) | (f a, b)
--   f (a, b, c | d) -&gt; (a, b, f c) |
--   </pre>
--   
--   <pre>
--   f (g a) <a>-</a> f (f (g a)), f (f (g a)) <a>-</a> f (g (f a))
--   f . g <a>-</a> f . f . g <a>-</a> f . g . f
--     duplicate    :: Comonad f =&gt; f (g a) -&gt; f (f (g a))
--   
--     extract      :: Comonad f =&gt; f (f (g a)) -&gt; f (g a)
--     fmap extract :: Comonad f =&gt; f (f (g a)) -&gt; f (g a)
--   </pre>
someValidPartitionsNotes :: ()

-- | If <tt>f</tt> is a comonad then we have:
--   
--   <pre>
--   iso duplicate extract :: f (g a) <a>-</a> f (f (g a))
--   </pre>
--   
--   Suppose f is not a comonad, then do we have duplicate and extract?
--   
--   <pre>
--    qa      :: f (g a)     -&gt; f (f (g a))
--    qb      :: f (f (g a)) -&gt; f (g a)
--    qc      :: f (f (g a)) -&gt; f (g (f a))
--    qd      :: f (g (f a)) -&gt; f (f (g a))
--    qc . qa :: f (g a)     -&gt; f (g (f a))
--    qb . qd :: f (g (f a)) -&gt; f (g a)
--    qa . qb = id
--    qb . qa = id
--    qc . qd = id
--    qd . qc = id
--   
--    f . g     = f . f . g
--    f . f . g = f . g . f
--    f . g     = f . g . f
--   
--    (f . g) . f = (f . g . f) . f
--    qa      :: f . g     = f . f . g
--    qc      :: f . f . g -&gt; f . g . f
--    qd      :: f (g (f a)) -&gt; f (f (g a))
--    qc . qa :: f (g a)     -&gt; f (g (f a))
--    qb . qd :: f (g (f a)) -&gt; f (g a)
--   
--   
--   Note 1: we don't have any way to derive a function of the type: (f a -&gt; a)
--    so we know that we can't get (Comonad f) for free
--   
--   Note 2: we don't have any way to derive a function of the type: (g a -&gt; a)
--    so we know that we can't get (Comonad g) for free
--   
--   Note 3: we don't have any way to derive a function of the type: (a -&gt; _)
--    so we know that we can't get Monad f, Monad g, Monad (f . g), Monad (g . f), etc for free
--   
--    (f (g a) -&gt; f (f (g a))) -&gt; (f a -&gt; f (f a))
--      wa :: f a -&gt; f (g a)
--      wb :: f (f (g a)) -&gt; f (f a)
--    (f (f (g a)) -&gt; f (g a)) -&gt; (f a -&gt; a)
--      wc :: f a -&gt; f (f (g a))
--      wd :: f (g a) -&gt; a
--   
--    wd . wa :: f a -&gt; a
--    wb . wc :: f a -&gt; f (f a)
--    With both:
--      (f (g a) -&gt; a) . (f a -&gt; f (g a)) = f a -&gt; a
--   
--    qq :: f (g a)     -&gt; f (f (g a))
--    ww :: f (f (g a)) -&gt; f (g a)
--    qq . ww = id
--    ww . qq = id
--   
--    ww = extract = fmap extract
--    qq = duplicate
--   </pre>
--   
--   Ff this is the case, then I believe that it implies <tt>(g a <a>-</a>
--   a)</tt>.
--   
--   <pre>
--   extract   :: f a -&gt; a
--   duplicate :: f a -&gt; f (f a)
--   duplicate .      extract = id
--   duplicate . fmap extract = id
--   
--   fmap distribute :: Functor     f, Distributive g =&gt; f (f (g a)) -&gt; f (g (f a))
--   fmap sequenceA  :: Traversable f, Applicative  g =&gt; f (f (g a)) -&gt; f (g (f a))
--   
--   fmap distribute :: Distributive f, Functor     g =&gt; f (g (f a)) -&gt; f (f (g a))
--   fmap sequenceA  :: Applicative  f, Traversable g =&gt; f (g (f a)) -&gt; f (f (g a))
--   
--   Functor f, Functor g
--    Comonad f
--      Distributive f, Distributive g
--      Distributive f, Traversable  f, Applicative g
--      Applicative  f, Traversable  g, Distributive g
--      Applicative  f, Traversable  g, Traversable f, Applicative g
--   </pre>
comonadComparison :: ()

-- | Series join points:
--   
--   Here's the idea: We take a list (series) of some datatype <tt>t</tt>
--   and we replace it with a list of <tt>t (_)</tt>, such that consecutive
--   elements of the same form (e.g. <tt>Left x, Left y || Right x, Right y
--   || (x, y), (z, w)</tt>) are joined together along equivalences and the
--   list pops out within the parameter (e.g. <tt>[(a, b1), (a, b2)] -&gt;
--   (a, [b1,b2])</tt>).
--   
--   What's required for this to be a unique construction is for the
--   structures to be partitioned by their "join points".
--   
--   <pre>
--   Left (_ :: a), Right (_ :: b) -&gt; Left (_ :: [a]), Right (_ :: [b])
--   (_ :: a, _ :: b) -&gt; (_ :: a, _ :: b)
--   Nothing, Just (_ :: a) -&gt; Nothing, Just [a]
--   </pre>
--   
--   Ahh, for it to be unique, each pair must map to either zero (don't
--   match) or one (do match) possible combinations.
--   
--   Question: Is this true iff there is one possible parsing of every
--   sentence in such a language? In other words, it is unambiguous?
--   
--   Note: In other words, we have a binary relation:
--   
--   <pre>
--   (~) :: (a :: k :: L) -&gt; (b :: k  :: L) -&gt; ('Just (a ~~ b) :: Maybe k :: L)
--   (~) :: (a :: k :: L) -&gt; (b :: k' :: L) -&gt; ('Nothing       :: Maybe k :: L)
--   </pre>
--   
--   It must be at least left/right (right, w.l.o.g.) associative for fixed
--   <tt>k</tt>.
--   
--   So we have three layers:
--   
--   <pre>
--   A language: L
--   The kind level (where terms with quivalent kinds combine)
--   The term level or GADT term level (The AST of the language)
--   </pre>
--   
--   If we attempt to combine two terms, for the combination to be unique,
--   we must have that their kinds are equal (that is, the kinds must form
--   a partition on the types).
--   
--   <pre>
--   Within a fixed kind, the operation must be associative (or just right/left associative?)
--   Between two kinds, I believe it may also be associative (hmm, it really probably only needs to be right/left associative)
--   </pre>
seriesJoinPoints :: ()

-- | An even stronger version forces a sequence on the resulting datatype,
--   for example, for a type-sum over a pair, we have the language:
--   
--   <pre>
--   L = { a(ba)*, b(ab)* }
--   </pre>
--   
--   Where the language <tt>L</tt> is equivalent to the language of
--   sequences formed by squashing over a list-like or linear data
--   structure.
--   
--   Note: In a complete binary tree as the outer structure, we instead
--   have that the <tt>a,b</tt>'s form a two-coloring of the binary tree.
--   However, <tt>L</tt> is still the language generated.
--   
--   More precisely:
--   
--   <pre>
--   a | b | (x :: a) -&gt; a, (b, (x :: a)), (b, (x :: a)) | (x :: b) -&gt; b, (a, (x :: b)), (a, (x :: b))
--   </pre>
--   
--   Thus it seems that the inner structure is determined by the outer one
--   (In this case, the inner structure is L and the outer structure is
--   Either)
strongerVersionSequence :: ()

-- | In Data.FGLang, we found that the laws:
--   
--   <pre>
--   f (g a) <a>-</a> f (f (g a)) <a>-</a> f (g (f a))
--   </pre>
--   
--   (Where the <tt>(<a>-</a>)</tt> are bijections, and <tt>f,g</tt> are
--   Functors.) generate a regular language of the form: <tt>(F+)G(F?)</tt>
--   representing what is reachable from <tt>f (g a)</tt>, i.e. the
--   non-free part of the language.
--   
--   This immediately shows that none of the following classes are implied:
--   
--   <pre>
--   Monad, Comonad, Applicative, Traversable, Distributive
--   </pre>
dataFGLanglaws :: ()
instance (GHC.Show.Show b, GHC.Show.Show a) => GHC.Show.Show (Data.SwapList.SwapList a b)
instance (GHC.Classes.Ord b, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.SwapList.SwapList a b)
instance (GHC.Classes.Eq b, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.SwapList.SwapList a b)
instance Data.Bifunctor.Bifunctor Data.SwapList.SwapList
instance Data.Bidistributable.Swap Data.SwapList.SwapList
instance Control.Comonad.Comonad f => Data.Rope.Twist f Data.SwapList.SwapList
instance Data.SwapList.Biexpandcontract Data.SwapList.SwapList Data.Either.Either []
