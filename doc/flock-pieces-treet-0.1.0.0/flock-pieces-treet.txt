-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package flock-pieces-treet
@version 0.1.0.0

module Control.Monad.Trans.TreeT

-- | A Generalized tree type
--   
--   Question: does any property such that
--   
--   <pre>
--   Prop :: * -&gt; Constraint
--     Prop a
--       =&gt; Prop (Tree Identity a)?
--     Prop a, Prop a + Prop b =&gt; Prop (a, b), Prop a =&gt; Prop (m a)
--       =&gt; Prop (Tree m a)?
--     Prop a =&gt; Prop (m a)
--       =&gt; Prop (Tree m a)?
--   Prop :: (* -&gt; *) -&gt; Constraint
--     Prop Identity, Prop a + Prop b =&gt; Prop (a :*: b), Prop m
--       =&gt; Prop (Tree m)?
--     Prop m
--       =&gt; Prop (Forest m)?
--   Prop :: (* -&gt; * -&gt; *) -&gt; Constraint
--     Prop (,), Prop t
--       =&gt; Prop (ATree t m)?
--     Prop t
--       =&gt; Prop (AForest t m)?
--   </pre>
--   
--   E.g.
--   
--   <pre>
--   instance Alternative m =&gt; Alternative (Forest m)@
--   </pre>
--   
--   But no instance for <tt><a>Tree</a> m</tt>
--   
--   E.g.
--   
--   <pre>
--   instance Functor m =&gt; Comonad (Tree m)
--   </pre>
--   
--   But no instance for <tt><a>Forest</a> m</tt>
newtype Tree m a
Tree :: (a, Forest m a) -> Tree m a
[getTree] :: Tree m a -> (a, Forest m a)

-- | The counterpart to <a>Tree</a>
newtype Forest m a
Forest :: m (Tree m a) -> Forest m a
[getForest] :: Forest m a -> m (Tree m a)
treeToCofree :: Functor m => Tree m a -> Cofree m a
cofreeToTree :: Functor m => Cofree m a -> Tree m a
forestToCofree :: Functor m => Forest m a -> m (Cofree m a)
cofreeToForest :: Functor m => m (Cofree m a) -> Forest m a

-- | <a>Tree</a> is not a monad transformer, but <tt><a>Tree</a> . m</tt>
--   is, for <tt><a>Monad</a> m</tt>
liftTree :: Monad m => m a -> m (Tree m a)

-- | Push a monadic context into a <a>Forest</a> by binding it and
--   unwrapping the forest.
--   
--   It should be equivalent to:
--   
--   <pre>
--   Forest . join . fmap getForest
--   Forest .        (&gt;&gt;= getForest)
--   </pre>

-- | Note that <a>Tree</a> can only be <a>Alternative</a> with constraints
--   on <tt>a</tt>, so it can't be <a>Alternative</a> in Haskell

-- | Pull out a layer of monadic context from a <a>Forest</a>.
--   
--   Not sure, but I think that the only inhabitants of this type can:
--   
--   <ul>
--   <li>return the original</li>
--   <li>do this</li>
--   <li>swap two <a>Tree</a> values</li>
--   <li>some combination of the above</li>
--   </ul>
pullM :: Functor m => Forest m a -> m (Forest m a)

-- | <a>pullM</a> and <a>extract</a>
pullMa :: Functor m => Forest m a -> m a

-- | Unfold a <a>Tree</a> from a seed value
unfoldTree :: Functor m => (b -> (a, m b)) -> b -> Tree m a

-- | Unfold a <a>Forest</a> from a seed value
unfoldForest :: Functor m => (b -> m (a, b)) -> b -> Forest m a
iterateTree :: Applicative m => (a -> m a) -> a -> m (Tree m a)
iterateForest :: Applicative m => (a -> m a) -> a -> Forest m a

-- | Algebraic notes:
--   
--   <pre>
--   -- f' = (f / g) * g'
--   -- f' = (f <i> g) * ((g </i> f) * f')
--   -- f' = (*) ((<i>) f g) ((*) ((</i>) g f) f')
--   -- f' = (f <tt>y</tt> g) <tt>x</tt> ((g <tt>y</tt> f) <tt>x</tt> f')
--   </pre>
--   
--   <pre>
--   f' x y f g = x (y f g) . x (y g f) $ f'
--   </pre>
--   
--   <pre>
--   -- g' = (g / f) * f'
--   -- g' = (g <i> f) * ((f </i> g) * g')
--   -- g' = (g <tt>y</tt> f) <tt>x</tt> ((f <tt>y</tt> g) <tt>x</tt> g')
--   </pre>
--   
--   <pre>
--   g' x y f g = x (y g f) . x (y f g) $ g'
--   </pre>
--   
--   <pre>
--   f' = (f <tt>y</tt> g) <tt>x</tt> g'
--   g' = (g <tt>y</tt> h) <tt>x</tt> h'
--   h' = (h <tt>y</tt> f) <tt>x</tt> f'
--   </pre>
--   
--   If <tt><tt>x</tt></tt> right-distributes over <tt><tt>y</tt></tt>:
--   
--   <pre>
--   f' = (f <tt>y</tt> g) <tt>x</tt> g' = (f <tt>y</tt> g') <tt>x</tt> (g <tt>y</tt> g')
--   g' = (g <tt>y</tt> h) <tt>x</tt> h' = (g <tt>y</tt> h') <tt>x</tt> (h <tt>y</tt> h')
--   h' = (h <tt>y</tt> f) <tt>x</tt> f' = (h <tt>y</tt> f') <tt>x</tt> (f <tt>y</tt> f')
--   
--   f' = (f <tt>y</tt> g) <tt>x</tt> g' = (f <tt>y</tt> g) <tt>x</tt> ((g <tt>y</tt> h) <tt>x</tt> ((h <tt>y</tt> f) <tt>x</tt> f'))
--   g' = (g <tt>y</tt> h) <tt>x</tt> h' = (g <tt>y</tt> h) <tt>x</tt> ((h <tt>y</tt> f) <tt>x</tt> ((f <tt>y</tt> g) <tt>x</tt> g'))
--   h' = (h <tt>y</tt> f) <tt>x</tt> f' = (h <tt>y</tt> f) <tt>x</tt> ((f <tt>y</tt> g) <tt>x</tt> ((g <tt>y</tt> h) <tt>x</tt> h'))
--   
--   f' = x (y f g) . x (y g f) $ f'
--   g' = x (y g f) . x (y f g) $ g'
--   
--   f' = x (y f g) g' = x (y f g) . x (y g h) . x (y h f) $ f'
--   g' = x (y g h) h' = x (y g h) . x (y h f) . x (y f g) $ g'
--   h' = x (y h f) f' = x (y h f) . x (y f g) . x (y g h) $ h'
--   
--   f' = x (y f g) g' = ((.) (x (y f g)) ((.) (x (y g h)) (x (y h f))) $ f'
--   g' = x (y g h) h' = x (y g h) . (x (y h f) . x (y f g)) $ g'
--   h' = x (y h f) f' = x (y h f) . (x (y f g) . x (y g h)) $ h'
--   </pre>
--   
--   <pre>
--   (.) :: cat b c -&gt; cat a b -&gt; cat a c
--   
--   (.) (x (y g h)) (x (y h f)) :: xygh b1 c1 -&gt; xyhf a1 b1 -&gt; ghf a1 c1
--   (.) (x (y h f)) (x (y f g)) :: xyhf b2 c2 -&gt; xyfg a2 b2 -&gt; hfg a2 c2
--   (.) (x (y f g)) (x (y g h)) :: xyfg b3 c3 -&gt; xygh a3 b3 -&gt; fgh a3 c3
--   
--   (.) (x (y f g)) :: xyfg c1 d1 -&gt; ghf a1 c1 -&gt; C1 a1 d1
--   (.) (x (y g h)) :: xygh c2 d2 -&gt; hfg a2 c2 -&gt; C2 a2 d2
--   (.) (x (y h f)) :: xyhf c3 d3 -&gt; fgh a3 c3 -&gt; C2 a3 d3
--   </pre>
--   
--   So <tt>x</tt> has to be at least a semigroupoid, to support
--   composition
--   
--   <pre>
--     furthermore, it has to lift all the pairs to a common category
--     furthermore, it has to be funtorial, to allow preservation of internal properties
--   y :: `f -&gt; `g -&gt; `(y f g)
--   y :: `g -&gt; `f -&gt; `(y g f)
--   </pre>
--   
--   <pre>
--   y :: `f -&gt; `g -&gt; `(y f g)
--   y :: `g -&gt; `h -&gt; `(y g h)
--   y :: `h -&gt; `f -&gt; `(y h f)
--   </pre>
algebraicNotes :: ()

-- | Algebraic examples:
--   
--   <pre>
--   La * Lb -&gt; La
--   
--   (La :*: Lb) a -&gt; La a
--   
--   (La -&gt; (La || Lb)) -&gt; (Lb -&gt; (La || Lb)) -&gt; (La -&gt; La - Lb)
--   
--   Suppose La &lt;= Lb
--   </pre>
--   
--   <pre>
--   A, B, A &amp;&amp; B, A || B, A * B, A + B
--   
--   Either A B
--   (A, B)
--   </pre>
algebraicExamples :: ()
considerLanguageCycle :: ()

-- | Thus we see that for languages based on <tt>(-&gt;)</tt>, aka
--   application, every property seems to hold on either <a>Tree</a> or
--   <a>Forest</a>:
--   
--   <ul>
--   <li>Because Tree is the combination of the Value language and the
--   Action language</li>
--   <li>Because ATree is the combination of the Semigroupoid language with
--   the Category language (ATree doesn't have identity, AForest does, even
--   though it contains ATree.)</li>
--   <li>OR because <tt>ATree</tt> is the product of <tt>(Category -
--   Identity)</tt> and <tt>Category</tt>..?</li>
--   <li>So all associtive-requiring properties hold for both and all
--   <tt>associative+identity</tt>-requiring properties only hold for
--   <tt>AForest</tt></li>
--   </ul>
--   
--   If this construction works, then I believe it may be "self-holding",
--   i.e. free: The primitives used to express it are exactly the
--   primitives needed to express it.
--   
--   If this works and forms an internally consistent language, then this
--   effectively adds a primitive form of implementation-agnostic,
--   decidable, recursion to Flock.
--   
--   It also allows the simple addition of Categories, Application, Type
--   hierarchies, etc. etc. etc.
--   
--   Note: While I'm unsure whether any n-lang in the Flock core is
--   sufficient to express itself, it's trivial to show that there's an
--   (n+m)-lang that does (because of regularity).
--   
--   Does this preserve: consistency, completeness, decidability,
--   finiteness, haltingness, etc?
--   
--   Well, if it's shown on a nice category-theoretic level, it doesn't
--   really matter, no?
--   
--   <pre>
--   Everything will be preserved, [evil-laugh] XD
--   </pre>
--   
--   (That still cracks me up)
--   
--   Natural extension of <tt>A</tt>. There is a function
--   
--   <pre>
--   f : A -&gt; A',
--   f' :: A' -&gt; A,
--   f' . f = id,
--   A' ~ A <a>=</a> f . f' = id
--   </pre>
--   
--   I wonder if this indeed forms a structure analogous to a factorization
--   system for arbitrary categories?
propertyPreservation :: ()

-- | More possibilities
--   
--   <pre>
--   f :: a -&gt; a',
--   f' :: a' -&gt; a,
--   f' . f = id,
--   Iso (a' ~ a) (f . f' = id)
--   </pre>
twoMoreAttempts :: ()

-- | Summarize and notes:
--   
--   <pre>
--   F, G functors from C to D
--   n, natural transformation F -&gt; G
--     nx :: forall (x :: C). F x -&gt; G x
--     forall (f :: (x :: C) -&gt; (y :: C)).
--       exists (ny :: F y -&gt; G y).
--       ny . F (f :: x -&gt; y) == G (f :: x -&gt; y) . nx
--   </pre>
--   
--   <pre>
--   Functor (f :: * -&gt; *)
--   Functor (g :: * -&gt; *)
--   </pre>
--   
--   <pre>
--   f' = (f / g) * g'
--   f' = (f <i> g) * ((g </i> f) * f')
--   f' = (*) ((<i>) f g) ((*) ((</i>) g f) f')
--   f' = (f <tt>y</tt> g) <tt>x</tt> ((g <tt>y</tt> f) <tt>x</tt> f')
--   f' = x (y f g) (x (y g f) f')
--   
--   g' = (g / f) * f'
--   g' = (g <i> f) * ((f </i> g) * g')
--   g' = (g <tt>y</tt> f) <tt>x</tt> ((f <tt>y</tt> g) <tt>x</tt> g')
--   </pre>
naturalTransformationAlgebra :: ()

-- | Free/Cofree and algebra
--   
--   <pre>
--   newtype Free f a = Free { unfree :: Either a (f (Free f a))) }
--     Either a (f (Free f a))
--     (Either a :.: f :.: Free f)
--   Sum version of Tree f a
--   </pre>
--   
--   <pre>
--   Cofree f a =  a :&lt;  (f (Cofree f a))
--     Tree f a =  a (,) (f (Tree   f a))
--   </pre>
--   
--   <pre>
--   Free f a = Pure a | Free (f (Free f a))
--   Free f a = Either a (f (Free f a))
--   Free f a = Either a (f (Either a (f (Free f a))))
--   Free f a = Either a (f -&gt; (a, (Either a (f -&gt; (a, )(Free f a)))))
--   Free (TT f a b) c = Either a (TT a b (Free (TT f a b) c))
--   Free (TT f a b) c = Either a (TT a b (Either a (TT a b (Free (TT f a b) c))))
--   </pre>
--   
--   <pre>
--   Forest (Either a . f) a = Either a (f (a, Forest f a))
--   Forest f a = f (a, Forest f a)
--   Forest f a = f (Tree f a)
--   </pre>
--   
--   <pre>
--   TT f a b = f a -&gt; (a, b)
--   </pre>
ttDefinition :: ()

-- | Free and Cofree instances:
--   
--   <pre>
--   newtype FreeT   f m a = FreeT   { runFreeT   :: m (FreeF f a (FreeT f m a)) }
--     newtype FreeT   f m a = m (Either a (f (FreeT f m a)))
--     newtype FreeT   f m a = m (Either a (f (m (Either a (f (FreeT f m a))))))
--   data FreeF   f a b = Pure a | Free (f b)
--     data FreeF   f a b = Either a (f b)
--   </pre>
--   
--   <pre>
--   newtype CofreeT f w a = CofreeT { runCofreeT :: w (CofreeF f a (CofreeT f w a)) }
--     newtype CofreeT f w a = w (a, f (CofreeT f w a))
--     newtype CofreeT f w a = w (a, f (w (a, f (CofreeT f w a))))
--   data CofreeF f a b = a :&lt; (f b)
--     data CofreeF f a b = (a, f b)
--   </pre>
--   
--   <pre>
--   Functor f =&gt; Monad (Free f a) =&gt; MonadFree f (Free f) =&gt;
--     wrap :: f (Free f a) -&gt; Free f a
--     wrap x = Pure  (x :: f (Free f a))
--     wrap x = Right (x :: f (Free f a))
--   
--   Monad f =&gt; Monad (Forest f a) =&gt;
--     wrap :: f (Forest f a) -&gt; Forest f a
--     wrap = (coerce :: (f (f (a, Forest f a)) -&gt; f (a, Forest f a)) -&gt; f (Forest f a) -&gt; Forest f a) (join :: Monad f =&gt; f (f (a, Forest f a)) -&gt; f (a, Forest f a))
--   </pre>
freeAndCofree :: ()

-- | Lift an <a>Enum</a> to a <a>Tree</a> type where the outermost is
--   first?
--   
--   Hmm.. I know that we can't use the internal monadic structure of
--   <a>Tree</a> since we know nothing about it.
--   
--   What would we like to do with this? well, it might be nice to add
--   labeling to a <a>Tree</a> using <a>Enum</a>
--   
--   <pre>
--   instance Enum a =&gt; Enum (Tree m a) where
--   
--   -- The functions below are for <a>Forest</a>, since we probably can't do <a>fromEnum</a>
--   
--   -- | the successor of a value. For numeric types, succ adds 1.
--   succM :: a -&gt; a
--   
--   -- | the predecessor of a value. For numeric types, pred subtracts 1.
--   predM :: a -&gt; a
--   
--   -- | Convert from an Int.
--   toEnumM :: Int -&gt; a
--   
--   -- | Convert to an Int. It is implementation-dependent what fromEnum returns when applied to a value that is too large to fit in an Int.
--   fromEnumM :: a -&gt; Int
--   
--   -- | Used in Haskell's translation of [n..].
--   enumFromM :: a -&gt; [a]
--   
--   -- | Used in Haskell's translation of [n,n'..].
--   enumFromThenM :: a -&gt; a -&gt; [a]
--   
--   -- | Used in Haskell's translation of [n..m].
--   enumFromToM :: a -&gt; a -&gt; [a]
--   
--   -- | Used in Haskell's translation of [n,n'..m].
--   enumFromThenToM :: a -&gt; a -&gt; a -&gt; [a]
--   </pre>
ideaInstanceEnum :: ()
instance GHC.Generics.Generic (Control.Monad.Trans.TreeT.Tree m a)
instance GHC.Generics.Generic (Control.Monad.Trans.TreeT.Forest m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.TreeT.Tree m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.TreeT.Forest m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.Monad.Trans.TreeT.Tree m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.Monad.Trans.TreeT.Forest m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.TreeT.Tree m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.TreeT.Forest m)
instance GHC.Base.Functor m => Control.Comonad.Comonad (Control.Monad.Trans.TreeT.Tree m)
instance GHC.Base.Applicative m => Control.Comonad.ComonadApply (Control.Monad.Trans.TreeT.Tree m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Trans.TreeT.Forest
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.TreeT.Forest m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.TreeT.Forest m)
instance Control.Comonad.Trans.Class.ComonadTrans Control.Monad.Trans.TreeT.Tree
instance Control.Comonad.Trans.Class.ComonadTrans Control.Monad.Trans.TreeT.Forest
instance Data.Functor.Classes.Eq1 t => Data.Functor.Classes.Eq1 (Control.Monad.Trans.TreeT.Tree t)
instance Data.Functor.Classes.Eq1 t => Data.Functor.Classes.Eq1 (Control.Monad.Trans.TreeT.Forest t)
instance Data.Functor.Classes.Ord1 t => Data.Functor.Classes.Ord1 (Control.Monad.Trans.TreeT.Tree t)
instance Data.Functor.Classes.Ord1 t => Data.Functor.Classes.Ord1 (Control.Monad.Trans.TreeT.Forest t)
instance GHC.Base.Monad m => Control.Monad.Free.Class.MonadFree m (Control.Monad.Trans.TreeT.Forest m)
instance (GHC.Base.Monoid a, GHC.Base.Applicative m) => GHC.Base.Monoid (Control.Monad.Trans.TreeT.Tree m a)
instance (GHC.Base.Monoid a, GHC.Base.Applicative m) => GHC.Base.Monoid (Control.Monad.Trans.TreeT.Forest m a)
instance (GHC.Base.Monoid a, GHC.Base.Applicative m) => Data.Semigroup.Semigroup (Control.Monad.Trans.TreeT.Tree m a)
instance (GHC.Base.Monoid a, GHC.Base.Applicative m) => Data.Semigroup.Semigroup (Control.Monad.Trans.TreeT.Forest m a)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Control.Monad.Trans.TreeT.Forest m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.TreeT.Forest m)
instance Control.Monad.Primitive.PrimBase m => Control.Monad.Primitive.PrimBase (Control.Monad.Trans.TreeT.Forest m)
instance Data.Foldable.Foldable m => Data.Foldable.Foldable (Control.Monad.Trans.TreeT.Tree m)
instance Data.Foldable.Foldable m => Data.Foldable.Foldable (Control.Monad.Trans.TreeT.Forest m)
instance Data.Traversable.Traversable m => Data.Traversable.Traversable (Control.Monad.Trans.TreeT.Tree m)
instance Data.Traversable.Traversable m => Data.Traversable.Traversable (Control.Monad.Trans.TreeT.Forest m)
instance (GHC.Base.Applicative m, GHC.Num.Num a) => GHC.Num.Num (Control.Monad.Trans.TreeT.Tree m a)
instance (GHC.Base.Applicative m, GHC.Num.Num a) => GHC.Num.Num (Control.Monad.Trans.TreeT.Forest m a)
instance (GHC.Base.Applicative m, GHC.Real.Fractional a) => GHC.Real.Fractional (Control.Monad.Trans.TreeT.Tree m a)
instance (GHC.Base.Applicative m, GHC.Real.Fractional a) => GHC.Real.Fractional (Control.Monad.Trans.TreeT.Forest m a)
instance (GHC.Base.Applicative m, GHC.Float.Floating a) => GHC.Float.Floating (Control.Monad.Trans.TreeT.Tree m a)
instance (GHC.Base.Applicative m, GHC.Float.Floating a) => GHC.Float.Floating (Control.Monad.Trans.TreeT.Forest m a)

module Control.Arrow.Tree

-- | Like <a>Tree</a>, but the arguments are applied differently, to allow
--   it to be an <a>Arrow</a>
newtype ATree t a b
ATree :: Tree (t a) b -> ATree t a b
[getATree] :: ATree t a b -> Tree (t a) b

-- | See <a>AForest</a>
newtype AForest t a b
AForest :: Forest (t a) b -> AForest t a b
[getAForest] :: AForest t a b -> Forest (t a) b

-- | @<a>o</a> = <a>laog'</a>

-- | Compose two <a>Tree</a>s
comp :: Tree ((->) b) c -> Tree ((->) a) b -> Tree ((->) a) c

-- | <a>coerce</a>
getTree2 :: (Tree ma a -> Tree mb b -> Tree mc c) -> (a, Forest ma a) -> (b, Forest mb b) -> (c, Forest mc c)

-- | <a>unsafeCoerce</a> is used for now, since the following error
--   appears:
--   
--   <pre>
--   • Couldn't match representation of type ‘t a (c, Forest (t a) c)’
--                              with that of ‘t a (Tree (t a) c)’
--       arising from a use of ‘coerce’
--     NB: We cannot know what roles the parameters to ‘t a’ have;
--       we must assume that the role is nominal
--   </pre>
--   
--   This is safe by the following:
--   
--   <pre>
--   (arr coerce .)   :: (Arrow t, Coercible b c) =&gt; t a b -&gt; t a c -- initial definition
--     = (coerce .)   :: (Arrow t, Coercible b c) =&gt; t a b -&gt; t a c -- arr id = id
--     = coerce       :: (Arrow t, Coercible b c) =&gt; t a b -&gt; t a c -- (id .) = id
--   </pre>
arrCoerce :: (Arrow a, Coercible c d) => a b c -> a b d

-- | <a>coerce</a> more strangely doesn't work here either. weird
goal' :: Arrow t => ATree t b c -> ATree t a b -> ATree t a c

-- | Goal function
goal :: Arrow t => Tree (t b) c -> Tree (t a) b -> Tree (t a) c

-- | <a>coerce</a>
trans1 :: ((a, Forest ma a) -> (b, Forest mb b) -> (c, Forest mc c)) -> Tree ma a -> Tree mb b -> Tree mc c

-- | <pre>
--   <a>trans2</a> <a>goal2</a>
--   </pre>
goal1 :: Arrow t => (c, Forest (t b) c) -> (b, Forest (t a) b) -> (c, Forest (t a) c)

-- | <a>coerce</a>
trans2 :: Arrow t => ((c, t b (Tree (t b) c)) -> (b, t a (Tree (t a) b)) -> (c, t a (Tree (t a) c))) -> (c, Forest (t b) c) -> (b, Forest (t a) b) -> (c, Forest (t a) c)

-- | Second goal function
--   
--   <pre>
--   goal2 (x, fx) (y, fy) = (x, arr (uncurry goal) . (fx . arr (const y) &amp;&amp;&amp; fy))
--   </pre>
goal2 :: Arrow t => (c, t b (Tree (t b) c)) -> (b, t a (Tree (t a) b)) -> (c, t a (Tree (t a) c))

-- | Coerce doesn't work here, which is too bad
laog' :: Arrow t => AForest t b c -> AForest t a b -> AForest t a c

-- | <pre>
--   <a>snart1</a> <a>laog1</a>
--   </pre>
laog :: Arrow t => Forest (t b) c -> Forest (t a) b -> Forest (t a) c

-- | <a>coerce</a>
snart1 :: Arrow t => (t b (Tree (t b) c) -> t a (Tree (t a) b) -> t a (Tree (t a) c)) -> Forest (t b) c -> Forest (t a) b -> Forest (t a) c

-- | <pre>
--   <a>snart2</a> <a>laog2</a>
--   </pre>
laog1 :: Arrow t => t b (Tree (t b) c) -> t a (Tree (t a) b) -> t a (Tree (t a) c)

-- | By the logic of <a>arrCoerce</a>, this use of <a>unsafeCoerce</a> is
--   safe
snart2 :: Arrow t => (t b (c, Forest (t b) c) -> t a (b, Forest (t a) b) -> t a (c, Forest (t a) c)) -> t b (Tree (t b) c) -> t a (Tree (t a) b) -> t a (Tree (t a) c)

-- | Opposite of <a>goal2</a>
laog2 :: Arrow t => t b (c, Forest (t b) c) -> t a (b, Forest (t a) b) -> t a (c, Forest (t a) c)

-- | Wow, coerce doesn't work here. I had to use the <a>AForest</a>
--   constructor instead
--   
--   Notes:
--   
--   So, technically, it appears that <a>Tree</a> is only a category when
--   we have a left-identity for <tt>`Arrow a`</tt>
--   
--   We can however do stuff like:
--   
--   <pre>
--   a -&gt; Tree (t a) a
--   t a (Tree (t a) a
--   </pre>
--   
--   <pre>
--   idTree :: Arrow t =&gt; Tree (t a) a
--   idTree1 :: Arrow t =&gt; (a, Forest (t a) a)
--   </pre>
idForest' :: Arrow t => AForest t a a

-- | See <a>idForest</a>
idForest :: Arrow t => Forest (t a) a

-- | <a>coerce</a>
transIdForest1 :: Arrow t => t a (Tree (t a) a) -> Forest (t a) a

-- | <pre>
--   <a>transIdForest2</a> <a>idForest2</a>
--   </pre>
idForest1 :: Arrow t => t a (Tree (t a) a)

-- | <a>arrCoerce</a>
transIdForest2 :: Arrow t => t a (a, Forest (t a) a) -> t a (Tree (t a) a)

-- | Coerced all the way up to <a>idForest</a>
idForest2 :: Arrow t => t a (a, Forest (t a) a)

-- | <tt>`(.)` = <a>laog'</a></tt>, <tt><a>id</a> = <a>idForest'</a></tt>

-- | <pre>
--   <a>o</a> = <a>goal'</a>
--   </pre>

-- | Notes on Data.Bifoldable, Data.Bitraversable, etc:
--   
--   <pre>
--   Data.Bifoldable
--   instance Bifoldable t =&gt; Bifoldable (ATree t) where
--     bifoldr :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; t a b -&gt; c
--     bifoldr :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; ATree t a b -&gt; c
--     bifoldr :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; Tree (t a) b -&gt; c
--   
--   This makes me think that Forest (t a) b ~ Forest (Forest t a) b, which would be amazeballs
--   Maybe something similar, like the <tt>wanted</tt> functions?
--   
--   instance Bifoldable t =&gt; Bifoldable (AForest t) where
--     bifoldr :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; t a b -&gt; c
--     bifoldr :: (a -&gt; c -&gt; c) -&gt; (b -&gt; c -&gt; c) -&gt; c -&gt; Forest (t a) b -&gt; c
--   </pre>
--   
--   <pre>
--   Data.Bitraversable
--   class (Bifunctor t, Bifoldable t) =&gt; Bitraversable t
--     bitraverse :: Applicative f =&gt; (a -&gt; f c) -&gt; (b -&gt; f d) -&gt; t a b -&gt; f (t c d)
--   </pre>
--   
--   <pre>
--   Data.Bifunctor.Functor
--   type (:-&gt;) p q = forall a b. p a b -&gt; q a b
--   
--   class BifunctorFunctor t where
--     bifmap :: (p :-&gt; q) -&gt; t p :-&gt; t q
--   </pre>
bifoldableNotes :: ()

-- | This looks a lot like distribution

-- | Re-associate a tuple
sndIn :: ((a, b), c) -> ((a, c), b)

-- | I'm pretty surprised that this isn't in base
assoc :: ((a, b), c) -> (a, (b, c))

-- | Inverse of <a>assoc</a>
unassoc :: (a, (b, c)) -> ((a, b), c)

-- | Lift functions, inside of a <a>Tree</a>, into <a>Arrow</a>s
--   
--   Scratch notes:
--   
--   <pre>
--   arr :: Arrow a =&gt; (b -&gt; c) -&gt; a b c
--   arr . const :: Arrow a =&gt; c -&gt; a b c
--   
--   arr Tree    :: Arrow a =&gt; a (c, Forest (a b) c) (Tree (a b) c)
--   arr getTree :: Arrow a =&gt; a (Tree (a b) c) (c, Forest (a b) c)
--   
--   arr Forest    :: Arrow a =&gt; a (a b (Tree (a b) c)) (Forest (a b) c)
--   arr getForest :: Arrow a =&gt; a (Forest (a b) c) (a b (Tree (a b) c))
--   </pre>
--   
--   Wow, this just blew my mind. If we have cat be an arrow, then the pair
--   operations that I use above are already given!!
--   
--   <pre>
--   TreeArrow (Tree (f, fs)) . TreeArrow (Tree (g, gs)) = TreeArrow (Tree (f, fs . gs))
--   </pre>
--   
--   <pre>
--   compf :: Forest ((-&gt;) b) c -&gt; Forest ((-&gt;) a) b -&gt; Forest ((-&gt;) a) c
--   compf :: (b -&gt; Tree ((-&gt;) b) c) -&gt; (a -&gt; Tree ((-&gt;) a) b) -&gt; (c -&gt; Tree ((-&gt;) a) c)
--   compf :: (b -&gt; (c, Forest ((-&gt;) b) c)) -&gt; (a -&gt; (b, Forest ((-&gt;) a) b)) -&gt; (c -&gt; (c, Forest ((-&gt;) a) c))
--   </pre>
--   
--   I'm willing to bet that Tree is analogous to True (as it's inhabited)
--   and Forest is analogous to False (as it's not, yet):
--   
--   <pre>
--   Tree &amp;&amp; Tree forms a Tree:   (a &amp; b -&gt; c) -&gt; (Tree m a &amp; Tree m b) -&gt; Tree m c
--   Tree || Forest forms a Tree: (a | b -&gt; c) -&gt; (Tree m a | Forest m b) -&gt; Tree m c
--   Forest || Forest forms a Tree: (a | b -&gt; c) -&gt; (Forest m a | Forest m b) -&gt; Forest m c
--   </pre>
--   
--   Ohhh, can we also lift inside? Duh, as long as m is applicative!
--   
--   <pre>
--   (a | b -&gt; c) -&gt; Tree m (a | b) -&gt; Tree m c
--   </pre>
--   
--   Can we convert a comonad to a monad?
--   
--   <pre>
--   (w a -&gt; a) looks like a monad to me, in fact, it appears to be: Forest (CoKleisi a) b,
--     Cokleisli { runCokleisli :: w a -&gt; b }
--     Instances: .. Monad (Cokleisli w a)
--   </pre>
--   
--   Can we convert a monad to a comonad?
--   
--   <pre>
--   (a, a -&gt; m a) looks like a comonad to me, in fact it appears to be: Tree State a
--   </pre>
treeArr :: Arrow a => Tree ((->) b) c -> Tree (a b) c

-- | <a>Forest</a> counterpart to <a>treeArr</a>
forestArr :: Arrow a => Forest ((->) b) c -> Forest (a b) c
instance GHC.Generics.Generic1 (Control.Arrow.Tree.AForest t a)
instance GHC.Generics.Generic (Control.Arrow.Tree.AForest t a b)
instance GHC.Generics.Generic1 (Control.Arrow.Tree.ATree t a)
instance GHC.Generics.Generic (Control.Arrow.Tree.ATree t a b)
instance Control.Arrow.Arrow t => Data.Semigroupoid.Semigroupoid (Control.Arrow.Tree.AForest t)
instance Control.Arrow.Arrow t => Control.Category.Category (Control.Arrow.Tree.AForest t)
instance GHC.Base.Functor (t a) => GHC.Base.Functor (Control.Arrow.Tree.AForest t a)
instance Data.Bifunctor.Bifunctor t => Data.Bifunctor.Bifunctor (Control.Arrow.Tree.ATree t)
instance Data.Bifunctor.Bifunctor t => Data.Bifunctor.Bifunctor (Control.Arrow.Tree.AForest t)
instance Data.Profunctor.Unsafe.Profunctor t => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Tree.ATree t)
instance Data.Profunctor.Unsafe.Profunctor t => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Tree.AForest t)
instance Data.Profunctor.Strong.Strong t => Data.Profunctor.Strong.Strong (Control.Arrow.Tree.AForest t)
instance Control.Arrow.Arrow t => Data.Semigroupoid.Semigroupoid (Control.Arrow.Tree.ATree t)
instance GHC.Base.Functor (t a) => GHC.Base.Functor (Control.Arrow.Tree.ATree t a)

module Control.Arrow.Tree.Experimental

-- | <pre>
--   <a>inv</a> = <a>forestInv</a>
--   </pre>

-- | <a>undefined</a>
forestInv :: (Arrow t, Groupoid t) => AForest t a b -> AForest t b a

-- | <a>undefined</a>
forestInv1 :: (Arrow t, Groupoid t) => Forest (t a) b -> Forest (t b) a

-- | <a>undefined</a>
forestInv2 :: (Arrow t, Groupoid t) => t a (Tree (t a) b) -> t b (Tree (t b) a)

-- | <a>undefined</a>
swaps :: Arrow t => t a (Tree (t a) b) -> t (Tree (t b) a) b

-- | <a>undefined</a>
swaps1 :: Arrow t => t a (b, Forest (t a) b) -> t (a, Forest (t b) a) b

-- | <a>undefined</a>. Ok, I'm convinced that this needs Groupoid
swaps2 :: Arrow t => t a (b, t a (Tree (t a) b)) -> t (a, t b (Tree (t b) a)) b

-- | This also looks a lot like distribution.. (<a>undefined</a>)

-- | This is harder than I thought, might be impossible, probably
--   impossible.
--   
--   Try extending <tt>Choice (ATree t)</tt> to not use <tt>Choice (AForest
--   t)</tt>.
--   
--   (Currently, both are <a>undefined</a>.)

-- | REQUIRES DISTRIBUTION: distribute :: Functor f =&gt; f (g a) -&gt; g
--   (f a), Functor f =&gt; f (Tree m a) -&gt; Tree m (f a)

-- | <a>undefined</a>
wantTo :: AForest t a (ATree t a b) -> AForest t (ATree t a b) b

-- | <a>undefined</a>
wantFrom :: AForest t (ATree t a b) b -> AForest t a (ATree t a b)

-- | Impossible instance, no way to convert <tt>a</tt> to <tt>b</tt>.
instance (Control.Arrow.Arrow t, Data.Groupoid.Groupoid t) => Data.Groupoid.Groupoid (Control.Arrow.Tree.AForest t)
instance Data.Biapplicative.Biapplicative t => Data.Biapplicative.Biapplicative (Control.Arrow.Tree.ATree t)
instance Data.Biapplicative.Biapplicative t => Data.Biapplicative.Biapplicative (Control.Arrow.Tree.AForest t)
instance Data.Profunctor.Choice.Choice t => Data.Profunctor.Choice.Choice (Control.Arrow.Tree.AForest t)
instance Data.Profunctor.Closed.Closed t => Data.Profunctor.Closed.Closed (Control.Arrow.Tree.ATree t)
instance Data.Profunctor.Closed.Closed t => Data.Profunctor.Closed.Closed (Control.Arrow.Tree.AForest t)
instance (Control.Arrow.Arrow t, Data.Groupoid.Groupoid t, (TypeError ...)) => Data.Groupoid.Groupoid (Control.Arrow.Tree.ATree t)
instance Data.Profunctor.Choice.Choice t => Data.Profunctor.Choice.Choice (Control.Arrow.Tree.ATree t)

module Data.Fix

-- | Simple fixed point newtype
newtype Fix f
Fix :: f (Fix f) -> Fix f
[runFix] :: Fix f -> f (Fix f)

-- | Convert a <a>Fix</a> to an infinite list
fixList :: Fix ((,) a) -> [a]

-- | Warning: produces an infinite <a>String</a>
instance GHC.Generics.Generic (Data.Fix.Fix f)
instance GHC.Show.Show a => GHC.Show.Show (Data.Fix.Fix ((,) a))

module Data.Flip

-- | A four-part mutually recursive data type
--   
--   Notes:
--   
--   Number of cycles: w.l.o.g we require the first element to be the
--   minimum
--   
--   <pre>
--   1 minimum
--   * permutations of all else
--   (n-1)! ?
--   </pre>
--   
--   E.g. for two, there's exactly one cycle:
--   
--   <pre>
--   Value, Container =&gt;
--     Value * Container (..), Container (Value * ..)
--     Value + Container (..), Container (Value + ..)
--   </pre>
--   
--   Interesting example: unary / binary
--   
--   <pre>
--   (a -&gt; b)
--   (a -&gt; b -&gt; c)
--   
--   a -&gt; b
--   a -&gt; (b -&gt; c)
--   a -&gt; (a, b, b -&gt; c)
--   b -&gt; (b, c)
--   a -&gt; (b, (b -&gt; (c, next)))
--   </pre>
--   
--   Want:
--   
--   Applicative instances for <a>F1</a>, <a>F3</a>
--   
--   <a>Comonad</a> instances for <a>F2</a>, <a>F4</a>
newtype F1 a b c
F1 :: (a -> F2 a b c) -> F1 a b c
[getF1] :: F1 a b c -> a -> F2 a b c

-- | Continuation of <a>F1</a>
newtype F2 a b c
F2 :: (b, F3 a b c) -> F2 a b c
[getF2] :: F2 a b c -> (b, F3 a b c)

-- | Continuation of <a>F2</a>
newtype F3 a b c
F3 :: (b -> F4 a b c) -> F3 a b c
[getF3] :: F3 a b c -> b -> F4 a b c

-- | Continuation of <a>F3</a>
newtype F4 a b c
F4 :: (c, F1 a b c) -> F4 a b c
[getF4] :: F4 a b c -> (c, F1 a b c)

-- | I believe the exact list of "free" morphisms between <tt>F</tt>'s is:
--   
--   <pre>
--   1 -&gt; 1          (we don't have an <tt>a</tt>, and F1's the only one that depends directly on <tt>a</tt>)
--   2 -&gt; 1, 2, 3, 4 (see implementations)
--   3 -&gt; 3          (as with F1, we don't have <tt>b</tt>..)
--   4 -&gt; 1, 4       (<a>snd</a> gives F1, then we get stuck)
--   </pre>
freeMorphismsNotes :: ()

-- | <a>id</a>
morphF11 :: F1 a b c -> F1 a b c
functorMorphF11 :: TestBatch

-- | <a>F2</a> to <a>F4</a>, then <a>F4</a> to <a>F1</a>
morphF21 :: F2 a b c -> F1 a b c
functorMorphF21 :: TestBatch

-- | <a>id</a>
morphF22 :: F2 a b c -> F2 a b c
functorMorphF22 :: TestBatch

-- | Get and <a>snd</a>
morphF23 :: F2 a b c -> F3 a b c
functorMorphF23 :: TestBatch

-- | Get and apply the <tt>b</tt> in <a>F2</a> to the function in <a>F3</a>
morphF24 :: F2 a b c -> F4 a b c
functorMorphF24 :: TestBatch

-- | <a>id</a>
morphF33 :: F3 a b c -> F3 a b c
functorMorphF33 :: TestBatch

-- | Get and <a>snd</a>
morphF41 :: F4 a b c -> F1 a b c
functorMorphF41 :: TestBatch

-- | <a>id</a>
morphF44 :: F4 a b c -> F4 a b c
functorMorphF44 :: TestBatch
testF1Functor :: TestBatch
testF2Functor :: TestBatch
testF3Functor :: TestBatch
testF4Functor :: TestBatch

-- | Stub instance

-- | Stub instance

-- | Note that of <a>F1</a>, <a>F2</a>, <a>F3</a>, and <a>F4</a>, only
--   <a>F4</a> is always a <a>Comonad</a> (if <tt>a ~ b ~ c</tt>, for
--   example, I believe <a>F2</a> would be one as well):
--   
--   <a>F1</a> would need <a>F2</a> to be a <a>Comonad</a>, and a default
--   value for <tt>a</tt>
--   
--   <a>F2</a> would require <a>F3</a> to be a <a>Comonad</a>
--   
--   <a>F3</a> would require a default value for <tt>b</tt>, and for
--   <a>F4</a> to be a <a>Comonad</a> (which I believe it is)
--   
--   <pre>
--   extend extract = ext
--     ext (F4 ~(x, xs)) = F4 (x, F1 . fmap (F2 . fmap (F3 . fmap ext . getF3) . getF2) . getF1 $ xs)
--   
--     since F1, F2, F3, getF1, getF2, getF3, fmap do not affect the values, aside from <tt>fmap ext</tt>, I believe this may be proof of: ext == id
--   
--   extend extract      = id
--   extract . extend f  = f
--   extend f . extend g = extend (f . extend g)
--   </pre>

-- | Like <a>flip</a>
newtype Flip f a b
Flip :: f b a -> Flip f a b
[getFlip] :: Flip f a b -> f b a

-- | <a>coerce</a>
withFlip :: (Flip f1 a1 b1 -> Flip f a b) -> f1 b1 a1 -> f b a

-- | <a>Flip</a> for three arguments
newtype Flip2 f a b c
Flip2 :: f c b a -> Flip2 f a b c
[getFlip2] :: Flip2 f a b c -> f c b a

-- | Coerce
withFlip2 :: (Flip2 f1 a1 b1 c1 -> Flip2 f a b c) -> f1 c1 b1 a1 -> f c b a

-- | A newtype to ensure generated functions (<a>Arbitrary</a>) are
--   inverses of each other
newtype SomeIso a b
SomeIso :: (b -> a, a -> b) -> SomeIso a b
[getSomeIso] :: SomeIso a b -> (b -> a, a -> b)

-- | Ignore arguments

-- | Unsigned integer addition is an inverse to subtraction

-- | Test <a>IsoFunctor</a>
testIsoFunctor :: (IsoFunctor f, EqProp (f a), Show (f a), Arbitrary (SomeIso a a), Arbitrary (f a)) => f a -> TestBatch

-- | A "functor" that requires an isomorphism to map over
class IsoFunctor f
isomap :: IsoFunctor f => (b -> a) -> (a -> b) -> f a -> f b

-- | Uses <a>Word</a>, <a>testIsoFunctor</a>
testIsoFunctorF1 :: TestBatch

-- | Uses <a>Word</a>, <a>testIsoFunctor</a>
testIsoFunctorF2 :: TestBatch

-- | Uses <a>Word</a>, <a>testIsoFunctor</a>
testIsoFunctorF3 :: TestBatch

-- | Uses <a>Word</a>, <a>testIsoFunctor</a>
testIsoFunctorF4 :: TestBatch

-- | All <a>TestBatch</a>s
testBatches :: [TestBatch]

-- | Run all test batches using <a>quickBatch</a>
quickTestBatches :: IO ()
instance GHC.Show.Show (f c b a) => GHC.Show.Show (Data.Flip.Flip2 f a b c)
instance GHC.Classes.Ord (f c b a) => GHC.Classes.Ord (Data.Flip.Flip2 f a b c)
instance GHC.Classes.Eq (f c b a) => GHC.Classes.Eq (Data.Flip.Flip2 f a b c)
instance Test.QuickCheck.Arbitrary.Arbitrary (f b a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.Flip f a b)
instance Test.QuickCheck.Checkers.EqProp (f b a) => Test.QuickCheck.Checkers.EqProp (Data.Flip.Flip f a b)
instance GHC.Show.Show (f b a) => GHC.Show.Show (Data.Flip.Flip f a b)
instance GHC.Classes.Ord (f b a) => GHC.Classes.Ord (Data.Flip.Flip f a b)
instance GHC.Classes.Eq (f b a) => GHC.Classes.Eq (Data.Flip.Flip f a b)
instance GHC.Show.Show b => GHC.Show.Show (Data.Flip.F2 a b c)
instance GHC.Show.Show c => GHC.Show.Show (Data.Flip.F4 a b c)
instance Data.Flip.IsoFunctor (Data.Flip.Flip (Data.Flip.F1 a) c)
instance Data.Flip.IsoFunctor (Data.Flip.Flip (Data.Flip.F2 a) c)
instance Data.Flip.IsoFunctor (Data.Flip.Flip (Data.Flip.F3 a) c)
instance Data.Flip.IsoFunctor (Data.Flip.Flip (Data.Flip.F4 a) c)
instance GHC.Show.Show (Data.Flip.SomeIso a b)
instance Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.SomeIso GHC.Types.Word GHC.Types.Word)
instance Data.Functor.Contravariant.Contravariant (Data.Flip.Flip2 Data.Flip.F1 a b)
instance Data.Functor.Contravariant.Contravariant (Data.Flip.Flip2 Data.Flip.F2 a b)
instance Data.Functor.Contravariant.Contravariant (Data.Flip.Flip2 Data.Flip.F3 a b)
instance Data.Functor.Contravariant.Contravariant (Data.Flip.Flip2 Data.Flip.F4 a b)
instance GHC.Base.Functor (Data.Flip.F1 a b)
instance GHC.Base.Functor (Data.Flip.F2 a b)
instance GHC.Base.Functor (Data.Flip.F3 a b)
instance GHC.Base.Functor (Data.Flip.F4 a b)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Show.Show a, Test.QuickCheck.Arbitrary.Arbitrary b, GHC.Classes.Eq b, GHC.Show.Show b, GHC.Classes.Eq c) => Test.QuickCheck.Checkers.EqProp (Data.Flip.F1 a b c)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Show.Show a, Test.QuickCheck.Arbitrary.Arbitrary b, GHC.Classes.Eq b, GHC.Show.Show b, GHC.Classes.Eq c) => Test.QuickCheck.Checkers.EqProp (Data.Flip.F2 a b c)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Show.Show a, Test.QuickCheck.Arbitrary.Arbitrary b, GHC.Classes.Eq b, GHC.Show.Show b, GHC.Classes.Eq c) => Test.QuickCheck.Checkers.EqProp (Data.Flip.F3 a b c)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Show.Show a, Test.QuickCheck.Arbitrary.Arbitrary b, GHC.Classes.Eq b, GHC.Show.Show b, GHC.Classes.Eq c) => Test.QuickCheck.Checkers.EqProp (Data.Flip.F4 a b c)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.CoArbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.F1 a b c)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.CoArbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.F2 a b c)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.CoArbitrary b, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.F3 a b c)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.CoArbitrary b, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.F4 a b c)
instance GHC.Show.Show (Data.Flip.F1 a b c)
instance GHC.Show.Show (Data.Flip.F3 a b c)
instance Control.Comonad.Comonad (Data.Flip.F4 a b)

module Data.Functor.Object

-- | Both a right result and a continuation (<a>Action</a>).
--   
--   Note: I was unable to derive an instance of <a>Generic1</a>: <tt>
--   Can't make a derived instance of ‘Generic1 (Object f b)’: Constructor
--   ‘Object’ applies a type to an argument involving the last parameter
--   but the applied type is not of kind * -&gt; * </tt>
data Object f b c
Object :: (c, Action f b c) -> Object f b c
[getObject] :: Object f b c -> (c, Action f b c)

-- | An action which could contain a left result, continuation
--   (<a>Object</a>)
data Action f b c
Action :: f b (Object f b c) -> Action f b c
[runAction] :: Action f b c -> f b (Object f b c)

-- | Cycle a pair, resulting in a fixed point
cyclePair :: Object (,) a b -> Fix ((,) (a, b))

-- | <pre>
--   <a>fixList</a> . <a>cyclePair</a>
--   </pre>
cyclePairList :: Object (,) a b -> [(a, b)]

-- | Given all the functional pairs to define a function, we can cyclically
--   wrap the pairs into an <a>Action</a> over pairs.
--   
--   Consider generalizing to other nice <tt>(* -&gt; * -&gt; *)</tt>'s
fromAll :: NonEmpty (a, b) -> Action (,) a b

-- | interesting..
ish :: (a -> b -> (a', b')) -> NonEmpty a -> NonEmpty b -> Action (,) a' b'

-- | Effectively define <a>fst</a> for an <a>Action</a> over pairs, using
--   all cases
fstIsh :: NonEmpty a -> NonEmpty b -> Action (,) (a, b) a

-- | Effectively define <a>snd</a> for an <a>Action</a> over pairs, using
--   all cases
sndIsh :: NonEmpty a -> NonEmpty b -> Action (,) (a, b) b

-- | Since there's only a finite number of a's, we can cycle through til we
--   match, then continue on
appIsh :: (Eq a, Functor (f t)) => Action (,) a b -> Object f t a -> Object f t b

-- | Undo an <a>Action</a>
unAction :: Functor (f b) => Action f b c -> f b c

-- | Undo an <a>Object</a>
unObject :: Functor (f b) => Object f b c -> (f b c, c)

-- | Convert to an <a>Action</a>
toAction :: Functor (f b) => f b c -> Action f b c

-- | Convert to an <a>Object</a>
toObject :: Functor (f b) => f b c -> c -> Object f b c

-- | <a>toAction</a>
fstAction :: Functor (f (b, c)) => f (b, c) b -> Action f (b, c) b

-- | <a>toObject</a>
fstObject :: Functor (f (b, c)) => f (b, c) b -> b -> Object f (b, c) b

-- | <a>toAction</a>
sndAction :: Functor (f (b, c)) => f (b, c) c -> Action f (b, c) c

-- | <a>toObject</a>
sndObject :: Functor (f (b, c)) => f (b, c) c -> c -> Object f (b, c) c

-- | <a>toAction</a>
swapAction :: Functor (f (b, c)) => f (b, c) (c, b) -> Action f (b, c) (c, b)

-- | <a>toObject</a>
swapObject :: Functor (f (b, c)) => f (b, c) (c, b) -> (c, b) -> Object f (b, c) (c, b)

-- | <a>toAction</a>
mapEitherAction :: Functor (f (c -> d, Either b c)) => f (c -> d, Either b c) (Either b d) -> Action f (c -> d, Either b c) (Either b d)

-- | <a>toObject</a>
mapEitherObject :: Functor (f (c -> d, Either b c)) => f (c -> d, Either b c) (Either b d) -> Either b d -> Object f (c -> d, Either b c) (Either b d)
instance GHC.Generics.Generic (Data.Functor.Object.Object f b c)
instance GHC.Generics.Generic (Data.Functor.Object.Action f b c)
instance GHC.Base.Functor (f b) => GHC.Generics.Generic1 (Data.Functor.Object.Action f b)
instance GHC.Base.Functor (f b) => GHC.Base.Functor (Data.Functor.Object.Object f b)
instance GHC.Base.Functor (f b) => GHC.Base.Functor (Data.Functor.Object.Action f b)
instance Control.Comonad.Comonad (f b) => Control.Comonad.Comonad (Data.Functor.Object.Object f b)
instance Control.Comonad.Comonad (f b) => Control.Comonad.Comonad (Data.Functor.Object.Action f b)

module Data.Functor.Result

-- | <tt>Object</tt>, but with a sum (<a>Either</a>) instead of a tuple
data Result f b c
Result :: Either c (Effect f b c) -> Result f b c
[getResult] :: Result f b c -> Either c (Effect f b c)

-- | <tt>Action</tt>, but with a sum (<a>Either</a>) instead of a tuple
data Effect f b c
Effect :: f b (Result f b c) -> Effect f b c
[runEffect] :: Effect f b c -> f b (Result f b c)

-- | Note that while both <a>Result</a> and <a>Effect</a> require
--   <a>Applicative</a> for an <a>Applicative</a> instance, <a>Result</a>
--   only needs a <a>Functor</a> instance to implement <a>&gt;&gt;=</a>.

-- | Note: while this function has a simple type, if the <a>Result</a>
--   cycles this functions result will be bottom
cycleSum :: Result Either a b -> Either a b
instance GHC.Base.Functor (f b) => GHC.Base.Functor (Data.Functor.Result.Result f b)
instance GHC.Base.Functor (f b) => GHC.Base.Functor (Data.Functor.Result.Effect f b)
instance GHC.Base.Applicative (f b) => GHC.Base.Applicative (Data.Functor.Result.Result f b)
instance GHC.Base.Applicative (f b) => GHC.Base.Applicative (Data.Functor.Result.Effect f b)
instance GHC.Base.Applicative (f b) => GHC.Base.Monad (Data.Functor.Result.Result f b)
instance GHC.Base.Monad (f b) => GHC.Base.Monad (Data.Functor.Result.Effect f b)
