<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.Bidistributable</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Data.Bidistributable.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">flock-pieces-treet-0.1.0.0</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.Bidistributable</p></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> <a href="../base-4.10.1.0/Data-Bifunctor.html#t:Bifunctor">Bifunctor</a> p =&gt; <a href="#t:Bidistributable">Bidistributable</a> p f <span class="keyword">where</span><ul class="subs"></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:Swap">Swap</a> p <span class="keyword">where</span><ul class="subs"></ul></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:RopeT">RopeT</a> p m a b = <a href="#v:RopeT">RopeT</a> {<ul class="subs"><li><a href="#v:pullRopeT">pullRopeT</a> :: p a (m (<a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m b a))</li></ul>}</li><li class="src short"><a href="#v:commonVariableTypes">commonVariableTypes</a> :: ()</li><li class="src short"><a href="#v:functorNotes">functorNotes</a> :: ()</li><li class="src short"><a href="#v:functorIsomorphismCompositions">functorIsomorphismCompositions</a> :: ()</li><li class="src short"><a href="#v:naturalIsomorphisms">naturalIsomorphisms</a> :: ()</li><li class="src short"><a href="#v:regularLanguage">regularLanguage</a> :: ()</li><li class="src short"><a href="#v:exampleApplications">exampleApplications</a> :: ()</li><li class="src short"><a href="#v:effectiveIdempotencePush">effectiveIdempotencePush</a> :: ()</li><li class="src short"><a href="#v:weakestVersionDuplicate">weakestVersionDuplicate</a> :: ()</li><li class="src short"><a href="#v:leftPartitionProperty">leftPartitionProperty</a> :: ()</li><li class="src short"><a href="#v:leastActionExhaustivity">leastActionExhaustivity</a> :: ()</li><li class="src short"><a href="#v:leastLeftAction">leastLeftAction</a> :: ()</li><li class="src short"><a href="#v:linearizationQuestion">linearizationQuestion</a> :: ()</li><li class="src short"><a href="#v:goingTheOtherWayLeastActions">goingTheOtherWayLeastActions</a> :: ()</li><li class="src short"><a href="#v:naturalTransformationUpToBijection">naturalTransformationUpToBijection</a> :: ()</li><li class="src short"><a href="#v:functorLimitNotes">functorLimitNotes</a> :: ()</li><li class="src short"><a href="#v:functorCompositionNotes">functorCompositionNotes</a> :: ()</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">class</span> <a href="../base-4.10.1.0/Data-Bifunctor.html#t:Bifunctor">Bifunctor</a> p =&gt; <a id="t:Bidistributable" class="def">Bidistributable</a> p f <span class="keyword">where</span> <a href="src/Data.Bidistributable.html#Bidistributable" class="link">Source</a> <a href="#t:Bidistributable" class="selflink">#</a></p><div class="doc"><p>Distribute over a <code><a href="../base-4.10.1.0/Data-Bifunctor.html#t:Bifunctor">Bifunctor</a></code></p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="Data-Bidistributable.html#v:bidistribute">bidistribute</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:bidistribute" class="def">bidistribute</a> :: f (p a b) -&gt; f (p (f a) (f b)) <a href="src/Data.Bidistributable.html#bidistribute" class="link">Source</a> <a href="#v:bidistribute" class="selflink">#</a></p><div class="doc"><p>Later called &quot;push&quot; and or &quot;push2&quot;</p></div></div><div class="subs instances"><p id="control.i:Bidistributable" class="caption collapser" onclick="toggleSection('i:Bidistributable')">Instances</p><div id="section.i:Bidistributable" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:ic:Bidistributable:Bidistributable:1" class="instance expander" onclick="toggleSection('i:ic:Bidistributable:Bidistributable:1')"></span> <a href="Data-Bidistributable.html#t:Bidistributable">Bidistributable</a> <a href="../base-4.10.1.0/Data-Either.html#t:Either">Either</a> []</span> <a href="src/Data.Bidistributable.html#line-39" class="link">Source</a> <a href="#t:Bidistributable" class="selflink">#</a></td><td class="doc"><p>Equivalent to grouping the <code><a href="../base-4.10.1.0/Data-Either.html#v:Left">Left</a></code> and <code><a href="../base-4.10.1.0/Data-Either.html#v:Right">Right</a></code> values together, then sequencing:</p><pre> Right . fmap (fromRight undefined) :: Functor f =&gt; f (Either a b) -&gt; Either a (f b)
 Left  . fmap (fromLeft  undefined) :: Functor f =&gt; f (Either a b) -&gt; Either (f a) b
</pre></td></tr><tr><td colspan="2"><div id="section.i:ic:Bidistributable:Bidistributable:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:bidistribute">bidistribute</a> :: [<a href="../base-4.10.1.0/Data-Either.html#t:Either">Either</a> a b] -&gt; [<a href="../base-4.10.1.0/Data-Either.html#t:Either">Either</a> [a] [b]] <a href="src/Data.Bidistributable.html#bidistribute" class="link">Source</a> <a href="#v:bidistribute" class="selflink">#</a></p></div></div></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:Swap" class="def">Swap</a> p <span class="keyword">where</span> <a href="src/Data.Bidistributable.html#Swap" class="link">Source</a> <a href="#t:Swap" class="selflink">#</a></p><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="Data-Bidistributable.html#v:swap">swap</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:swap" class="def">swap</a> :: p a b -&gt; p b a <a href="src/Data.Bidistributable.html#swap" class="link">Source</a> <a href="#v:swap" class="selflink">#</a></p></div><div class="subs instances"><p id="control.i:Swap" class="caption collapser" onclick="toggleSection('i:Swap')">Instances</p><div id="section.i:Swap" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:ic:Swap:Swap:1" class="instance expander" onclick="toggleSection('i:ic:Swap:Swap:1')"></span> <a href="Data-Bidistributable.html#t:Swap">Swap</a> <a href="../base-4.10.1.0/Data-Either.html#t:Either">Either</a></span> <a href="src/Data.Bidistributable.html#line-53" class="link">Source</a> <a href="#t:Swap" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:ic:Swap:Swap:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:swap">swap</a> :: <a href="../base-4.10.1.0/Data-Either.html#t:Either">Either</a> a b -&gt; <a href="../base-4.10.1.0/Data-Either.html#t:Either">Either</a> b a <a href="src/Data.Bidistributable.html#swap" class="link">Source</a> <a href="#v:swap" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:ic:Swap:Swap:2" class="instance expander" onclick="toggleSection('i:ic:Swap:Swap:2')"></span> <a href="Data-Bidistributable.html#t:Swap">Swap</a> <a href="../ghc-prim-0.5.1.1/GHC-Tuple.html#t:-40--44--41-">(,)</a></span> <a href="src/Data.Bidistributable.html#line-50" class="link">Source</a> <a href="#t:Swap" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:ic:Swap:Swap:2" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:swap">swap</a> :: (a, b) -&gt; (b, a) <a href="src/Data.Bidistributable.html#swap" class="link">Source</a> <a href="#v:swap" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:ic:Swap:Swap:3" class="instance expander" onclick="toggleSection('i:ic:Swap:Swap:3')"></span> <a href="Data-Bidistributable.html#t:Swap">Swap</a> <a href="Data-SwapList.html#t:SwapList">SwapList</a></span> <a href="src/Data.Bidistributable.html#line-66" class="link">Source</a> <a href="#t:Swap" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:ic:Swap:Swap:3" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:swap">swap</a> :: <a href="Data-SwapList.html#t:SwapList">SwapList</a> a b -&gt; <a href="Data-SwapList.html#t:SwapList">SwapList</a> b a <a href="src/Data.Bidistributable.html#swap" class="link">Source</a> <a href="#v:swap" class="selflink">#</a></p></div></div></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a id="t:RopeT" class="def">RopeT</a> p m a b <a href="src/Data.Bidistributable.html#RopeT" class="link">Source</a> <a href="#t:RopeT" class="selflink">#</a></p><div class="doc"><p><code>Rope</code> transformer type</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:RopeT" class="def">RopeT</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:pullRopeT" class="def">pullRopeT</a> :: p a (m (<a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m b a))</dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div><div class="subs instances"><p id="control.i:RopeT" class="caption collapser" onclick="toggleSection('i:RopeT')">Instances</p><div id="section.i:RopeT" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:RopeT:Bifunctor:1" class="instance expander" onclick="toggleSection('i:id:RopeT:Bifunctor:1')"></span> (<a href="../base-4.10.1.0/Data-Bifunctor.html#t:Bifunctor">Bifunctor</a> p, <a href="../base-4.10.1.0/Data-Functor.html#t:Functor">Functor</a> m) =&gt; <a href="../base-4.10.1.0/Data-Bifunctor.html#t:Bifunctor">Bifunctor</a> (<a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m)</span> <a href="src/Data.Bidistributable.html#line-62" class="link">Source</a> <a href="#t:RopeT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:RopeT:Bifunctor:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:bimap">bimap</a> :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a c -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m b d <a href="#v:bimap" class="selflink">#</a></p><p class="src"><a href="#v:first">first</a> :: (a -&gt; b) -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a c -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m b c <a href="#v:first" class="selflink">#</a></p><p class="src"><a href="#v:second">second</a> :: (b -&gt; c) -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a b -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a c <a href="#v:second" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:RopeT:Biapplicative:2" class="instance expander" onclick="toggleSection('i:id:RopeT:Biapplicative:2')"></span> (<a href="../bifunctors-5.5/Data-Biapplicative.html#t:Biapplicative">Biapplicative</a> p, <a href="../base-4.10.1.0/Control-Applicative.html#t:Applicative">Applicative</a> m) =&gt; <a href="../bifunctors-5.5/Data-Biapplicative.html#t:Biapplicative">Biapplicative</a> (<a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m)</span> <a href="src/Data.Bidistributable.html#line-69" class="link">Source</a> <a href="#t:RopeT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:RopeT:Biapplicative:2" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:bipure">bipure</a> :: a -&gt; b -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a b <a href="#v:bipure" class="selflink">#</a></p><p class="src"><a href="#v:-60--60--42--62--62-">(&lt;&lt;*&gt;&gt;)</a> :: <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m (a -&gt; b) (c -&gt; d) -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a c -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m b d <a href="#v:-60--60--42--62--62-" class="selflink">#</a></p><p class="src"><a href="#v:-42--62--62-">(*&gt;&gt;)</a> :: <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a b -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m c d -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m c d <a href="#v:-42--62--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--60--42-">(&lt;&lt;*)</a> :: <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a b -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m c d -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a b <a href="#v:-60--60--42-" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:RopeT:Functor:3" class="instance expander" onclick="toggleSection('i:id:RopeT:Functor:3')"></span> (<a href="../base-4.10.1.0/Data-Bifunctor.html#t:Bifunctor">Bifunctor</a> p, <a href="../base-4.10.1.0/Data-Functor.html#t:Functor">Functor</a> m) =&gt; <a href="../base-4.10.1.0/Data-Functor.html#t:Functor">Functor</a> (<a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a)</span> <a href="src/Data.Bidistributable.html#line-65" class="link">Source</a> <a href="#t:RopeT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:RopeT:Functor:3" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a a -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a b -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a a <a href="#v:-60--36-" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:RopeT:Applicative:4" class="instance expander" onclick="toggleSection('i:id:RopeT:Applicative:4')"></span> (<a href="../bifunctors-5.5/Data-Biapplicative.html#t:Biapplicative">Biapplicative</a> p, <a href="../base-4.10.1.0/Control-Applicative.html#t:Applicative">Applicative</a> m, <a href="../base-4.10.1.0/Data-Monoid.html#t:Monoid">Monoid</a> a) =&gt; <a href="../base-4.10.1.0/Control-Applicative.html#t:Applicative">Applicative</a> (<a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a)</span> <a href="src/Data.Bidistributable.html#line-76" class="link">Source</a> <a href="#t:RopeT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:RopeT:Applicative:4" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a a <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a (a -&gt; b) -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a a -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a a -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a b -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a a -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a b -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a a -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a b -&gt; <a href="Data-Bidistributable.html#t:RopeT">RopeT</a> p m a a <a href="#v:-60--42-" class="selflink">#</a></p></div></div></td></tr></table></div></div></div><div class="top"><p class="src"><a id="v:commonVariableTypes" class="def">commonVariableTypes</a> :: () <a href="src/Data.Bidistributable.html#commonVariableTypes" class="link">Source</a> <a href="#v:commonVariableTypes" class="selflink">#</a></p><div class="doc"><p>Commonly used variable types:</p><pre>f :: t -&gt; t
g :: t -&gt; t
a :: t
</pre></div></div><div class="top"><p class="src"><a id="v:functorNotes" class="def">functorNotes</a> :: () <a href="src/Data.Bidistributable.html#functorNotes" class="link">Source</a> <a href="#v:functorNotes" class="selflink">#</a></p><div class="doc"><p>Let <code>C</code> be a category. <code>F</code> associates (<code>X</code> is an object in <code>C</code> and <code>G(X)</code> is as well):</p><pre>  a  :: X      =&gt; F(a) :: F(X)
  f  :: X -&gt; Y =&gt; F(f) :: F(X) -&gt; F(Y)
  id_X :: X -&gt; X =&gt; F(id_X) = id_F(X) :: F(X) -&gt; F(X)
  f :: X -&gt; Y, g :: Y -&gt; Z, g . f :: X -&gt; Z =&gt; F (g . f) = F(g) . F(f) :: F(X) -&gt; F(Z)

                     G associates (X is an object in C and G(X) is as well)
  a  :: X      =&gt; G(a) :: G(X)
  f  :: X -&gt; Y =&gt; G(f) :: G(X) -&gt; G(Y)
  id_X :: X -&gt; X =&gt; G(id_X) = id_G(X) :: G(X) -&gt; G(X)
  f :: X -&gt; Y, g :: Y -&gt; Z, g . f :: X -&gt; Z =&gt; G (g . f) = G(g) . G(f) :: G(X) -&gt; G(Z)
</pre></div></div><div class="top"><p class="src"><a id="v:functorIsomorphismCompositions" class="def">functorIsomorphismCompositions</a> :: () <a href="src/Data.Bidistributable.html#functorIsomorphismCompositions" class="link">Source</a> <a href="#v:functorIsomorphismCompositions" class="selflink">#</a></p><div class="doc"><p>We want: functor isomorphisms between these compositions of F and G:</p><pre>  F(G(A))    -- we have a composition of functors
  F(F(G(A))) -- we partition the outer functor into pieces such that `unique partition (xs :: f (g a))` is true for our partition (if it exists, of course, that's where graph coloring comes in)
  F(G(F(A))) -- we push the partition into the inner functor, resulting in the connected (f (g a)) pieces being joined along their partitions.
</pre><p>In other words, it pulls the partition up to F's level while pushing the structure of F down into G. The structure of F is available to G in slices (local by definition of the partition).</p><p>Note: all of these operations are invertible since we have unique partitions.</p><p>Additionally, the functors which this works for are local functors and computers _really_ like computational and data locality. Like they simply adore it.
 Computational locality makes stream and massively parallel processing a breeze (case in point, the line-by-line parser I just wrote)</p></div></div><div class="top"><p class="src"><a id="v:naturalIsomorphisms" class="def">naturalIsomorphisms</a> :: () <a href="src/Data.Bidistributable.html#naturalIsomorphisms" class="link">Source</a> <a href="#v:naturalIsomorphisms" class="selflink">#</a></p><div class="doc"><p>That is, we want three natural transformations that are also isomorphisms between those compositions.</p><pre>  f :: X -&gt; Y =&gt; F(G(f)) :: F(G(X)) -&gt; F(G(Y))

  X :: C =&gt; eta_1(X) :: F(G(X)) -&gt; F(F(G(X))) :: C -&gt; C
  X :: C =&gt; eta_2(X) :: F(F(G(X))) -&gt; F(G(F(X))) :: C -&gt; C
  X :: C =&gt; eta_3(X) :: F(G(F(X))) -&gt; F(G(X)) :: C -&gt; C

  f :: X -&gt; Y :: C -&gt; C =&gt; eta_1(Y) . F(G(f)) = F(F(G(f))) . eta_1(X) :: F(G(X)) -&gt; F(F(G(Y))) :: C -&gt; C
  f :: X -&gt; Y :: C -&gt; C =&gt; eta_2(Y) . F(F(G(f))) = F(G(F(f))) . eta_2(X) :: F(F(G(X))) -&gt; F(G(F(Y))) :: C -&gt; C
  f :: X -&gt; Y :: C -&gt; C =&gt; eta_3(Y) . F(G(F(f))) = F(G(f)) . eta_3(X) :: F(G(F(X))) -&gt; F(G(Y)) :: C -&gt; C
</pre><p>We require these natural transformations to be bijections.</p><pre>The three base words (those functor compositions) are equivalent
Functor composition is associative
We have a compositional identity, the identity functor
</pre></div></div><div class="top"><p class="src"><a id="v:regularLanguage" class="def">regularLanguage</a> :: () <a href="src/Data.Bidistributable.html#regularLanguage" class="link">Source</a> <a href="#v:regularLanguage" class="selflink">#</a></p><div class="doc"><p>We thus have a group with the binary operation (.), identity the category identity, every element is invertible because we have isomorphisms between the compositions.</p><p>It has the presentation: <code>f g = f f g = f g f</code>.</p><p>Since it is a group, we can form the language of elements equivalent to those three words.</p><p>This diagram makes it clear:</p><p>(the lines are equivalence and the . is composition)</p><pre>
            (f . g)
              / 
             /   
            /     
           /       
          /         
  f . (f . g) --- (f . g) . f
</pre><p>First of all, we have the word &quot;fg&quot;.</p><pre>  Next, we have the word formed by performing the substitution &quot;fg -&gt; fgf&quot;, namely &quot;fgf&quot;.
  Next, we have the word formed by performing the substitution &quot;fg -&gt; ffg&quot;, namely &quot;ffg&quot;.
</pre><p>The substitution rules in full are as follows (with the substring &quot;fg&quot; wrapped in parentheses for emphasis alone):</p><pre> &quot;(fg)  -&gt; f(fg)&quot;
 &quot;f(fg) -&gt; (fg)&quot;
 &quot;(fg)  -&gt; (fg)f&quot;
 &quot;(fg)f -&gt; (fg)&quot;
 &quot;f(fg) -&gt; (fg)f&quot;
 &quot;(fg)f -&gt; f(fg)&quot;
 ----------------
   It's a rote exercise to show that any rule of the form &quot;f?(fg)f? -&gt; f?(fg)f?&quot; can be derived.
</pre><p>Since the substring &quot;fg&quot; can never be broken by the available base rules, we simply have the ability to induct on &quot;f?(fg)f? -&gt; f?(fg)f?&quot; to form &quot;f{n}(fg)f{m}&quot; for any n,m.</p><p>We simply compose the base rule with itself (max n m) times. We then resolve the optionals (?'s) to the number of &quot;f&quot;'s desired on either side of the &quot;(fg)&quot; center.</p><p>We thus have that this language is exactly the regular language: <code>&quot;(f*)(fg)(f*)&quot;</code></p></div></div><div class="top"><p class="src"><a id="v:exampleApplications" class="def">exampleApplications</a> :: () <a href="src/Data.Bidistributable.html#exampleApplications" class="link">Source</a> <a href="#v:exampleApplications" class="selflink">#</a></p><div class="doc"><p>One example application is <code>[], Maybe</code>, where pushing <code>([Maybe a] -&gt; [Maybe [a]])</code> partitions by isJust. This is stream-friendly.</p><p>Another example is <code>ListT IO, Threaded</code>, where <code>Threaded</code> is a comonad that evaluates its contents on extract,
 which we can do purely since we're still inside of <code>ListT IO</code> and couldn't do otherwise.</p><p>Pushing in is some parallel execution strategy, in that case.</p><p>In other words, we can use this to treat monads as comonads. We just do: <code>(Monad m =&gt; Turn (Compose m f) m)</code> and the inner <code>m</code> can be treated as a comonad inside the turn.</p><p>I.e. we have: <code>Monad m =&gt; m (Comonad m =&gt; ())</code></p><p>This could be well-typed if GHC supported impredicative polymorphism, but it doesn't.</p><p>How does it work?</p><pre> Well, inside of <code>m</code>, we have extract (m (m a) -&gt; m a), which is just join
 Also, inside of <code>m</code>, we still have return so then we get duplicate (m (m a) -&gt; m (m (m a))), which is return = fmap return
</pre><p>Inside of a comonad, we get a monad. This is the free comonad (/monad)</p><p>Ahhh, don't forget about orthogonal lists, e.g. a 2d array. this may be able to pass layers in and out</p></div></div><div class="top"><p class="src"><a id="v:effectiveIdempotencePush" class="def">effectiveIdempotencePush</a> :: () <a href="src/Data.Bidistributable.html#effectiveIdempotencePush" class="link">Source</a> <a href="#v:effectiveIdempotencePush" class="selflink">#</a></p><div class="doc"><p>Really, we want two applications of push to be equivalent to pure push (we don't gain anything from pushing more)
   (the benefit is that it's equivalent to the limit of the other pushes OR you can consider it as a guarantee that everything to be pushed is pushed in the first push)</p><p>This is: &quot;pushes are effectively idempotent&quot;
 (using some &quot;generic&quot; injection into <code>f</code> to show that additional pushes do no more than the generic injection)</p><pre>  push  :: forall (a :: c). f (g a) -&gt; f (g (f a))
  puref :: forall (a :: c). a -&gt; f a

  push      . push :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))
  fmap (fmap puref) . push :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))
  push . push == fmap (fmap puref) . push
</pre><p>This is: &quot;pushes are effectively idempotent&quot;
 (using some &quot;generic&quot; extraction from <code>f</code> (which arguably, we can guarantee in some way when we want all of the strcuture of f that can be pushed to be))</p><pre>  push     :: forall (a :: c). f (g a) -&gt; f (g (f a))
  extractf :: forall (a :: c). f a -&gt; a

  push . push                :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))
  fmap (fmap extractf) . push . push :: f (g a) -&gt; f (g (f a))

  fmap (fmap extractf) . push . push == push
</pre><p>This is: &quot;pushes are effectively idempotent&quot;
 (using some &quot;generic&quot; joining of <code>f</code>s)</p><pre>  push  :: forall (a :: c). f (g a) -&gt; f (g (f a))
  joinf :: forall (a :: c). f (f a) -&gt; f a

  push . push                :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))
  fmap (fmap joinf) . push . push :: f (g a) -&gt; f (g (f a))

  fmap (fmap joinf) . push . push == push
</pre><p>This is: &quot;pushes are effectively idempotent&quot;
 (using some &quot;generic&quot; duplication of <code>f</code>'s)</p><pre>  push       :: forall (a :: c). f (g a) -&gt; f (g (f a))
  duplicatef :: forall (a :: c). f a -&gt; f (f a)

  push . push                :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))
  fmap (fmap duplicatef) . push      :: forall (a :: c). f (g a) -&gt; f (g (f (f a)))

  fmap (fmap duplicatef) . push == push . push
</pre></div></div><div class="top"><p class="src"><a id="v:weakestVersionDuplicate" class="def">weakestVersionDuplicate</a> :: () <a href="src/Data.Bidistributable.html#weakestVersionDuplicate" class="link">Source</a> <a href="#v:weakestVersionDuplicate" class="selflink">#</a></p><div class="doc"><p>I believe that the weakest version is a duplicate that is injective?</p><p>Hmm, suppose we are within a context. This context is composable with itself.</p><ul><li>We want any <a href="-">-</a> 1, which is equivalent to having 2 <a href="-">-</a> 1.</li><li>We want this to be a natural transformation.</li><li>Ahh, what if we had: f (f a) -&gt; Maybe (f a)</li><li>Then, we could define the other mappings to match it so that it's always Just.</li></ul><p>Regardless, we want to be able to show that the additional compositions provided by pushes are trivial.</p></div></div><div class="top"><p class="src"><a id="v:leftPartitionProperty" class="def">leftPartitionProperty</a> :: () <a href="src/Data.Bidistributable.html#leftPartitionProperty" class="link">Source</a> <a href="#v:leftPartitionProperty" class="selflink">#</a></p><div class="doc"><p>Really, we probably want to have this property on the left as well, namely:
 partitioning an already partitioned functor only adds a trivial layer, since the functor has already been partitioned.</p><pre>  partition :: f (g a)  -&gt; f (f (g a))
  fmap partition . partition = fmap puref . partition
  fmap extract . fmap partition . partition = partition
</pre></div></div><div class="top"><p class="src"><a id="v:leastActionExhaustivity" class="def">leastActionExhaustivity</a> :: () <a href="src/Data.Bidistributable.html#leastActionExhaustivity" class="link">Source</a> <a href="#v:leastActionExhaustivity" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:leastLeftAction" class="def">leastLeftAction</a> :: () <a href="src/Data.Bidistributable.html#leastLeftAction" class="link">Source</a> <a href="#v:leastLeftAction" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:linearizationQuestion" class="def">linearizationQuestion</a> :: () <a href="src/Data.Bidistributable.html#linearizationQuestion" class="link">Source</a> <a href="#v:linearizationQuestion" class="selflink">#</a></p><div class="doc"><p>Question: can we linearize this?</p><p>Yes, we just map words of functions of type <code>f (g a) -&gt; f (f (g a))</code> using the following patterns:</p><pre> f0
 fmap f0 . f1
 fmap (fmap f0) . fmap f1 . f2
</pre><p>Quality preserves the lengths of words, because the words have unique types.</p><p>We want that (<code>p=partition</code>):</p><pre>&quot;pp&quot; -&gt; &quot;_p&quot;
</pre><p>Now, what is this blank? Hmm.</p><pre> eta(x) :: f (g (f x)) -&gt; f (g (f (f x)))
 fn :: x -&gt; y =&gt; eta(y) . f (g (f x)) == f (g (f (f x))) . eta(x)

 eta^(-1)(x) . eta(y) . f (g (f x)) == f (g (f (f x)))
 eta^(-1)(x) . eta(y) . f (g x) == f (f (g x))
</pre><p>We want the &quot;real&quot; one to stay fixed on the leftmost of the compositions of <code>f</code>s.</p></div></div><div class="top"><p class="src"><a id="v:goingTheOtherWayLeastActions" class="def">goingTheOtherWayLeastActions</a> :: () <a href="src/Data.Bidistributable.html#goingTheOtherWayLeastActions" class="link">Source</a> <a href="#v:goingTheOtherWayLeastActions" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:naturalTransformationUpToBijection" class="def">naturalTransformationUpToBijection</a> :: () <a href="src/Data.Bidistributable.html#naturalTransformationUpToBijection" class="link">Source</a> <a href="#v:naturalTransformationUpToBijection" class="selflink">#</a></p><div class="doc"><p>Suppose we have some natural transformation: <code>f . g -&gt; f . h</code>.
   Is this equivalent to some natural transformation: <code>g -&gt; h</code>, up to bijection?</p><p>One way, take <code>f</code>'s identity natural transformation <code>id_f :: f -&gt; f</code>.
 Then the left composition with <code>(g -&gt; h)</code> is another natural transformation: <code>(f . g -&gt; f . h)</code>, and since <code>id_f</code> is a bijection this is as well. Q.E.D.</p><p>Another way, we have some natural transformation from <code>(f . g -&gt; f . h)</code>.</p><pre>    eta is a natural transformation from (f . g) to (f . h).
    X :: C =&gt; eta_X :: (f . g) x -&gt; (f . h) x
    X :: C =&gt; beta_X :: g x -&gt; h x
    eta_Y . (f . g) fn = (f . h) fn . eta_X
      fn :: X -&gt; Y

    eta_(beta_Y) . (f . g) fn = (f . h) fn . eta_(beta_X)

    eta_X :: f x -&gt; f x
    beta_X :: g x -&gt; h x
</pre><p>Well, this suggests that we can only go the other way when we have a bijection from <code>(f . g)</code> to <code>(f . h)</code></p><p>Otherwise, we wouldn't be able to form bijections between <code>(eta_X :: (f . g) x -&gt; (f . h) x)</code> and <code>(beta_X :: g x -&gt; h x)</code>.</p><pre> eta . f . beta . f' == (id :: (f . h) x -&gt; (f . h) x) =&gt; f :: h x -&gt; (f . g) x, f' :: (f . h) x -&gt; g x
 beta . g . eta . g' == (id :: h x -&gt; h x) =&gt; g :: (f . h) x -&gt; g x, g' :: h x -&gt; (f . g) x
</pre><pre> g == f . g
 g == f . h
 h == f . g
 h == f . h
 g == h

 f == f . g
</pre><pre> (g) must be a left identity of (f) under composition
</pre><p>Results:</p><pre> An injective mapping from a natural transformation :: (g -&gt; h) to one :: (f . g -&gt; f . h) is trivial.
 An injective mapping from a natural transformation :: (f . g -&gt; f . h) to one :: (g -&gt; h) exists iff (g == h) and (f == f . g), i.e. (g) must be a left identity of (f) under composition.
</pre></div></div><div class="top"><p class="src"><a id="v:functorLimitNotes" class="def">functorLimitNotes</a> :: () <a href="src/Data.Bidistributable.html#functorLimitNotes" class="link">Source</a> <a href="#v:functorLimitNotes" class="selflink">#</a></p><div class="doc"><p>Question, is the limit of some functor inhabited? e.g.</p><pre>  The limit of Maybe is inhabited by:
    Nothing
    Just Nothing
    Just (Just Nothing)
    (the natural numbers)
  The limit of (x -&gt; (a, x)) has exactly one inhabitant:
    (a, (a, (a, (a, ..))))
    (a right-infinite list)
  The limit of (x -&gt; Either a x) has the inhabitants:
    Left a
    Right (Left a)
    Right (Right (Left a)
    (the pair (Nat, a))
</pre><p>what about expressing the limit of pushes? That's probably something like:</p><pre>  f (g a) -&gt; f (g (Fix f a))
  no... hmmm
</pre></div></div><div class="top"><p class="src"><a id="v:functorCompositionNotes" class="def">functorCompositionNotes</a> :: () <a href="src/Data.Bidistributable.html#functorCompositionNotes" class="link">Source</a> <a href="#v:functorCompositionNotes" class="selflink">#</a></p><div class="doc"><p>Some notes on composing sequences of functors</p><pre>f . g == f . g . f
f . g == (f . g) . f == ((f . g) . f) . f == (((f . g) . f) . f) . f
f . g == f . (f . g) == f . (f . (f . g)) == f . (f . (f . (f . g)))
</pre><pre>a; a,b; a,b,a; a,b,a,b
b; b,a; b,a,b; b,a,b,a
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.18.1</p></div></body></html>